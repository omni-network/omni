---
title: Multi-Step Deposits
description: How to configure an order for more complex interactions.
---

import { Callout } from 'vocs/components'

# Multi-Step Deposits

The Omni SDK allows you to compose multiple contract interactions on the destination chain within a single cross-chain order. This powerful feature enables complex workflows, such as depositing funds into one protocol and then staking the resulting token in another, all atomically from the user's perspective.

This guide demonstrates how to configure a multi-step order using the `useOrder` hook and the `calls` parameter.

## Example Scenario

Imagine a user wants to deposit USDC on a source chain (e.g., Ethereum) and have it automatically deposited into a stablecoin vault on a destination chain (e.g., Optimism). The vault issues a receipt token (let's call it `newUSD`). The user then wants to stake this `newUSD` in a separate staking contract on the same destination chain, receiving a final staked token (let's call it `stkNewUSD`).

The required steps on the destination chain are:

1.  Deposit USDC into the Vault contract (receiving `newUSD`).
2.  Approve the Staking contract to spend the received `newUSD` tokens.
3.  Stake the `newUSD` tokens in the Staking contract for the user (receiving `stkNewUSD`).

We can bundle these destination chain actions into a single Omni SDK order.

## Key Considerations

*   **Token Approvals via SolverNet Middleman:** When executing `calls`, the solver acts through a proxy contract called the `SolverNet Middleman` on the destination chain. This Middleman contract is the actual `msg.sender` for your target contract calls. In our example, the Middleman receives the `newUSD` from the vault. Consequently, the *Middleman* must be the one to call `approve` on the `newUSD` token contract, granting the Staking contract permission to spend its tokens.

<Callout type="info">
The Middleman contract is deployed at `0x08711eb144a394755d88d987dedca4b411b3eebe` on mainnet and `0x1b99e432d5f9e8110102b8d3dce2d0b462a37942` on testnet.
</Callout>

*   **Static Amounts:** The `amount` used within the `calls` sequence (e.g., for approvals or subsequent interactions like staking) must be statically defined when configuring the order. The system does **not** dynamically read the output amount from one call (like the amount of `newUSD` received from the vault) to use as input for a subsequent call. You must know and specify the exact amounts required for each step beforehand. For many deposit-and-stake scenarios where the vault issues tokens 1:1, the amount for the approval and staking steps will match the initial deposit amount.


## ðŸ› ï¸ Step-by-Step Configuration

### 1. Obtain a Quote Using `useQuote`

First, get a quote for the initial cross-chain transfer (USDC to USDC in this case, as the solver needs USDC on the destination to initiate the flow).

```tsx
import { useQuote } from '@omni-network/react'
import { parseUnits } from 'viem'

const quote = useQuote({
  srcChainId: 1, // Replace with actual source chain ID (e.g., Ethereum)
  destChainId: 10, // Replace with actual destination chain ID (e.g., Optimism)
  deposit: {
    token: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC on source
    amount: parseUnits('1000', 6), // 1000 USDC
  },
  expense: {
    token: '0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85', // USDC on destination
    amount: parseUnits('1000', 6), // Requesting 1000 USDC expense
  },
  mode: 'expense', // Calculate deposit based on desired expense
});
```

### 2. Define Contract ABIs

You'll need the ABIs for the contracts involved in the *destination chain* interactions:

**Vault Contract ABI (Example):**

```tsx
const vaultABI = [
  {
    inputs: [
      { internalType: 'address', name: 'recipient', type: 'address' },
      { internalType: 'uint256', name: 'amount', type: 'uint256' },
    ],
    name: 'deposit',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
] as const;
```

**Staking Contract ABI (Example):**

```tsx
const stakingABI = [
  {
    inputs: [
      { internalType: 'address', name: 'beneficiary', type: 'address' },
      { internalType: 'uint256', name: 'amount', type: 'uint256' },
    ],
    name: 'stakeFor',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
] as const;
```

**ERC20 ABI (for `approve`):**

```tsx
const erc20ABI = [
  {
    inputs: [
      { internalType: 'address', name: 'spender', type: 'address' },
      { internalType: 'uint256', name: 'amount', type: 'uint256' },
    ],
    name: 'approve',
    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
] as const;
```

### 3. Configure `useOrder` with Destination Calls

Pass the quote data and define the sequence of destination contract calls using the `calls` array.

```tsx
import { useOrder } from '@omni-network/react'

// --- Replace with actual values ---
const vaultAddress = '0x...'; // Address of the vault contract on destination
const newUSDTokenAddress = '0x...'; // Address of the vault's receipt token (newUSD)
const stakingContractAddress = '0x...'; // Address of the staking contract
const middlemanAddress = '0x...'; // Address of the SolverNet Middleman contract
const userAddress = '0x...'; // User's wallet address
const depositAmount = parseUnits('1000', 6); // The amount of USDC being deposited / newUSD being staked
// --- End Replace ---

const order = useOrder({
  // Ensure quote data is available and valid
  quote: quote.data,
  calls: [
    {
      // 1. Deposit USDC into the Vault, crediting SolverNet Middleman
      target: vaultAddress,
      abi: vaultABI,
      functionName: 'deposit',
      // Vault receives USDC, credits `middlemanAddress` (Middleman) with `newUSD`
      args: [middlemanAddress, depositAmount],
    },
    {
      // 2. SolverNet Middleman approves Staking contract to spend its `newUSD`
      target: newUSDTokenAddress,
      abi: erc20ABI,
      functionName: 'approve',
      args: [stakingContractAddress, depositAmount],
    },
    {
      // 3. SolverNet Middleman stakes `newUSD` for the user (receiving stkNewUSD implicitly)
      target: stakingContractAddress,
      abi: stakingABI,
      functionName: 'stakeFor',
      args: [userAddress, depositAmount],
    },
  ],
});
```

**Explanation:**

*   `calls`: An array of objects, each defining a contract call to be executed sequentially on the destination chain by the solver via the `SolverNet Middleman`.
*   **Call 1:** The Middleman calls the `vaultAddress`'s `deposit` function. We assume the vault credits the `recipient` (`middlemanAddress`) with `newUSD` tokens.
*   **Call 2:** The Middleman calls `approve` on the `newUSDTokenAddress`, granting the `stakingContractAddress` permission to spend the `newUSD` tokens it received in step 1.
*   **Call 3:** The Middleman calls the `stakingContractAddress`'s `stakeFor` function, staking the `newUSD` tokens on behalf of the `userAddress`. The user effectively receives `stkNewUSD` as a result of this action.

### 4. Execute the Order

Once the order is configured and the user confirms, trigger the execution:

```tsx
const handleExecute = async () => {
  // Add checks: ensure order and order.data are defined and quote is valid
  if (order.isReady && order.open) {
    try {
      const receipt = await order.open();
      // Handle successful transaction
      console.log('Order submitted:', receipt?.transactionHash);
    } catch (error) {
      // Handle error
      console.error('Failed to submit order:', error);
    }
  }
};
```

Congrats! You completed a complex order in 1 action for your users.
