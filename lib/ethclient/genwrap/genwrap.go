// Command genwrap provides a code generator for ethclient.Client wrapper
// that adds prometheus metrics and error wrapping.
//
// This code was mostly copied from Obol's Charon repo.
// https://github.com/ObolNetwork/charon/blob/main/app/eth2wrap/genwrap/genwrap.go
//
//nolint:gochecknoglobals,prealloc,gocognit // Some static config is required. Prealloc not worth it.
package main

import (
	"bytes"
	"context"
	"fmt"
	"github.com/omni-network/omni/lib/errors"
	"github.com/omni-network/omni/lib/log"
	"go/ast"
	"go/printer"
	"go/token"
	"golang.org/x/tools/imports"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"

	_ "github.com/ethereum/go-ethereum"
	"golang.org/x/tools/go/packages"
)

var (
	tpl = `package ethclient

// Code generated by genwrap.go. DO NOT EDIT.

import (
	"github.com/omni-network/omni/lib/errors"
	"github.com/ethereum/go-ethereum"
{{- range .Imports}}
	{{.}}
{{- end}}
)

// Client defines all ethereum interfaces used in omni.
type Client interface {
    {{range .Providers}} ethereum.{{.}}
    {{end -}}
	HeaderByType(ctx context.Context, typ HeadType) (*types.Header, error)
	EtherBalanceAt(ctx context.Context, addr common.Address) (float64, error)
	PeerCount(ctx context.Context) (uint64, error)
	SetHead(ctx context.Context, height uint64) error
	Address() string
	Close()
}

{{range .Methods}}
	{{.Doc}}
	func (w Wrapper) {{.Name}}({{.Params}}) ({{.ResultTypes}}) {
		const endpoint = "{{.Label}}"
		{{if .Latency}}defer latency(w.chain, endpoint)() {{end}}

		ctx, span := tracer.Start(ctx, spanName(endpoint))
		defer span.End()

		{{.ResultNames}} := w.cl.{{.Name}}({{.ParamNames}})
		if err != nil {
			incError(w.chain, endpoint)
			err = errors.Wrap(err, "json-rpc", "endpoint", endpoint)
		}

		return {{.ResultNames}}
	}
{{end}}
`

	// interfaces defines all the interfaces to implement.
	interfaces = map[string]bool{
		"ChainReader":        true,
		"TransactionReader":  true,
		"ChainStateReader":   true,
		"ChainSyncReader":    true,
		"ContractCaller":     true,
		"LogFilterer":        true,
		"TransactionSender":  true,
		"GasPricer":          true,
		"GasPricer1559":      true,
		"PendingStateReader": true,
		"GasEstimator":       true,
		"BlockNumberReader":  true,
		"ChainIDReader":      true,
	}

	// addImport indicates which types need hardcoded imports.
	addImport = map[string]string{
		"CallMsg":       "ethereum",
		"FilterQuery":   "ethereum",
		"*SyncProgress": "ethereum",
		"Subscription":  "ethereum",
	}

	// successFuncs indicates which endpoints have custom success functions.
	successFuncs = map[string]string{}

	skipImport = map[string]bool{
		"\"errors\"": true,
	}
)

type Method struct {
	Name        string
	Doc         string
	Latency     bool
	DoFunc      string
	SuccessFunc string
	params      []Field
	results     []Field
}

func (m Method) Label() string {
	return toSnakeCase(m.Name)
}

func (m Method) Params() string {
	var resp []string
	for _, param := range m.params {
		resp = append(resp, fmt.Sprintf("%s %s", param.Name, param.Type))
	}

	return strings.Join(resp, ", ")
}

func (m Method) Results() string {
	var resp []string
	for _, result := range m.results {
		resp = append(resp, fmt.Sprintf("%s %s", result.Name, result.Type))
	}

	return strings.Join(resp, ", ")
}

func (m Method) ParamNames() string {
	var resp []string
	for _, param := range m.params {
		resp = append(resp, param.Name)
	}

	return strings.Join(resp, ", ")
}

func (m Method) NamedResults() string {
	var resp []string
	for _, result := range m.results {
		resp = append(resp, fmt.Sprintf("%s %s", result.Name, result.Type))
	}

	return strings.Join(resp, ", ")
}

func (m Method) ResultNames() string {
	var resp []string
	for _, result := range m.results {
		resp = append(resp, result.Name)
	}

	return strings.Join(resp, ", ")
}

func (m Method) ResultTypes() string {
	var resp []string
	for _, result := range m.results {
		resp = append(resp, result.Type)
	}

	return strings.Join(resp, ", ")
}

type Field struct {
	Name string
	Type string
}

func main() {
	ctx := context.Background()
	err := run(ctx)
	if err != nil {
		log.Error(ctx, "‚ùå Fatal error", err)
	}
}

func run(_ context.Context) error {
	pkgs, err := packages.Load(
		&packages.Config{
			Mode: packages.NeedSyntax | packages.NeedTypesInfo | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedTypes,
		},
		"github.com/ethereum/go-ethereum",
	)
	if err != nil {
		return errors.Wrap(err, "load package")
	}

	methods, providers, err := parseEthMethods(pkgs[0])
	if err != nil {
		return err
	}

	imprts, err := parseImports(pkgs[0])
	if err != nil {
		return err
	}

	return writeTemplate(methods, providers, imprts)
}

func parseImports(pkg *packages.Package) ([]string, error) {
	var (
		dups = make(map[string]bool)
		resp []string
	)

	for _, file := range pkg.Syntax {
		for _, imprt := range file.Imports {
			var b bytes.Buffer
			err := printer.Fprint(&b, pkg.Fset, imprt)
			if err != nil {
				return nil, errors.Wrap(err, "printf")
			}

			name := b.String()
			if skipImport[name] {
				continue
			}

			dups[name] = true
			resp = append(resp, name)
		}
	}

	return resp, nil
}

func writeTemplate(methods []Method, providers []string, imprts []string) error {
	t, err := template.New("").Parse(tpl)
	if err != nil {
		return errors.Wrap(err, "parse template")
	}

	sort.Strings(providers)

	var b bytes.Buffer
	err = t.Execute(&b, struct {
		Providers []string
		Methods   []Method
		Imports   []string
	}{
		Providers: providers,
		Methods:   methods,
		Imports:   imprts,
	})
	if err != nil {
		return errors.Wrap(err, "exec template")
	}

	filename := "ethclient_gen.go"
	out, err := imports.Process(filename, b.Bytes(), nil)
	if err != nil {
		return errors.Wrap(err, "format")
	}

	err = os.WriteFile(filename, out, 0o644)
	if err != nil {
		return errors.Wrap(err, "write file")
	}

	return nil
}

func parseEthMethods(pkg *packages.Package) ([]Method, []string, error) {
	var (
		methods   []Method
		providers []string
	)
	for _, file := range pkg.Syntax {
		for _, decl := range file.Decls {
			gendecl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			if gendecl.Tok != token.TYPE {
				continue
			}

			for _, spec := range gendecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				iface, ok := typeSpec.Type.(*ast.InterfaceType)
				if !ok {
					continue
				}

				latency, add := interfaces[typeSpec.Name.Name]
				if !add {
					continue
				}

				providers = append(providers, typeSpec.Name.Name)

				for _, method := range iface.Methods.List {
					fnType, ok := method.Type.(*ast.FuncType)
					if !ok {
						continue
					}

					name := method.Names[0].Name

					var params []Field
					for _, param := range fnType.Params.List {
						var b bytes.Buffer
						err := printer.Fprint(&b, pkg.Fset, param.Type)
						if err != nil {
							return nil, nil, errors.Wrap(err, "printf")
						}

						typ := b.String()
						if imprt, ok := addImport[typ]; ok {
							typ = imprt + "." + typ
						}

						field := Field{
							Name: param.Names[0].Name,
							Type: typ,
						}

						params = append(params, field)
					}

					var results []Field
					for i, result := range fnType.Results.List {
						var b bytes.Buffer
						err := printer.Fprint(&b, pkg.Fset, result.Type)
						if err != nil {
							return nil, nil, errors.Wrap(err, "printf")
						}

						typ := b.String()
						if imprt, ok := addImport[typ]; ok {
							prefix := ""
							if strings.HasPrefix(typ, "*") {
								prefix = "*"
								typ = strings.TrimPrefix(typ, "*")
							}
							typ = prefix + imprt + "." + typ
						}

						name := fmt.Sprintf("res%d", i)
						if i == fnType.Results.NumFields()-1 {
							name = "err"
						}

						field := Field{
							Name: name,
							Type: typ,
						}

						results = append(results, field)
					}

					var doc string
					if method.Doc != nil {
						for _, line := range strings.Split(strings.TrimSpace(method.Doc.Text()), "\n") {
							doc += "// " + line + "\n"
						}
					}

					successFunc := "nil,"
					if fn, ok := successFuncs[name]; ok {
						successFunc = fn + ","
					}

					dofunc := "provide"
					if len(results) == 1 {
						dofunc = "submit"
						successFunc = ""
					}

					methods = append(methods, Method{
						Name:        name,
						Doc:         doc,
						Latency:     latency,
						DoFunc:      dofunc,
						SuccessFunc: successFunc,
						params:      params,
						results:     results,
					})
				}
			}
		}
	}

	return methods, providers, nil
}

var (
	matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
	matchAllCap   = regexp.MustCompile("([a-z0-9])([A-Z])")
)

func toSnakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")

	return strings.ToLower(snake)
}
