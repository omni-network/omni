/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
} from '@solana/kit'
import {
  type EVMCall,
  type EVMCallArgs,
  type EVMTokenExpense,
  type EVMTokenExpenseArgs,
  type Status,
  type StatusArgs,
  getEVMCallDecoder,
  getEVMCallEncoder,
  getEVMTokenExpenseDecoder,
  getEVMTokenExpenseEncoder,
  getStatusDecoder,
  getStatusEncoder,
} from '../types/index.js'

export const ORDER_STATE_DISCRIMINATOR = new Uint8Array([
  60, 123, 67, 162, 96, 43, 173, 225,
])

export function getOrderStateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(ORDER_STATE_DISCRIMINATOR)
}

export type OrderState = {
  discriminator: ReadonlyUint8Array
  orderId: Address
  status: Status
  owner: Address
  createdAt: bigint
  closableAt: bigint
  claimableBy: Address
  bump: number
  depositAmount: bigint
  depositMint: Address
  destChainId: bigint
  destCall: EVMCall
  destExpense: EVMTokenExpense
  fillHash: Address
  rejectReason: number
}

export type OrderStateArgs = {
  orderId: Address
  status: StatusArgs
  owner: Address
  createdAt: number | bigint
  closableAt: number | bigint
  claimableBy: Address
  bump: number
  depositAmount: number | bigint
  depositMint: Address
  destChainId: number | bigint
  destCall: EVMCallArgs
  destExpense: EVMTokenExpenseArgs
  fillHash: Address
  rejectReason: number
}

export function getOrderStateEncoder(): Encoder<OrderStateArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['orderId', getAddressEncoder()],
      ['status', getStatusEncoder()],
      ['owner', getAddressEncoder()],
      ['createdAt', getI64Encoder()],
      ['closableAt', getI64Encoder()],
      ['claimableBy', getAddressEncoder()],
      ['bump', getU8Encoder()],
      ['depositAmount', getU64Encoder()],
      ['depositMint', getAddressEncoder()],
      ['destChainId', getU64Encoder()],
      ['destCall', getEVMCallEncoder()],
      ['destExpense', getEVMTokenExpenseEncoder()],
      ['fillHash', getAddressEncoder()],
      ['rejectReason', getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: ORDER_STATE_DISCRIMINATOR }),
  )
}

export function getOrderStateDecoder(): Decoder<OrderState> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['orderId', getAddressDecoder()],
    ['status', getStatusDecoder()],
    ['owner', getAddressDecoder()],
    ['createdAt', getI64Decoder()],
    ['closableAt', getI64Decoder()],
    ['claimableBy', getAddressDecoder()],
    ['bump', getU8Decoder()],
    ['depositAmount', getU64Decoder()],
    ['depositMint', getAddressDecoder()],
    ['destChainId', getU64Decoder()],
    ['destCall', getEVMCallDecoder()],
    ['destExpense', getEVMTokenExpenseDecoder()],
    ['fillHash', getAddressDecoder()],
    ['rejectReason', getU8Decoder()],
  ])
}

export function getOrderStateCodec(): Codec<OrderStateArgs, OrderState> {
  return combineCodec(getOrderStateEncoder(), getOrderStateDecoder())
}

export function decodeOrderState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<OrderState, TAddress>
export function decodeOrderState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<OrderState, TAddress>
export function decodeOrderState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
): Account<OrderState, TAddress> | MaybeAccount<OrderState, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getOrderStateDecoder(),
  )
}

export async function fetchOrderState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<OrderState, TAddress>> {
  const maybeAccount = await fetchMaybeOrderState(rpc, address, config)
  assertAccountExists(maybeAccount)
  return maybeAccount
}

export async function fetchMaybeOrderState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<OrderState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config)
  return decodeOrderState(maybeAccount)
}

export async function fetchAllOrderState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<OrderState>[]> {
  const maybeAccounts = await fetchAllMaybeOrderState(rpc, addresses, config)
  assertAccountsExist(maybeAccounts)
  return maybeAccounts
}

export async function fetchAllMaybeOrderState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<OrderState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
  return maybeAccounts.map((maybeAccount) => decodeOrderState(maybeAccount))
}
