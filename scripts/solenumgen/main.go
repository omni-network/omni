// Command solenumgen generates golang enum bindings for solidity enums.
// This is a workaround for abigen that doesn't generate enums.
package main

import (
	"bytes"
	"context"
	"flag"
	"github.com/omni-network/omni/lib/errors"
	"github.com/omni-network/omni/lib/log"
	"golang.org/x/tools/imports"
	"os"
	"strings"
	"text/template"
)

var (
	flagInput   = flag.String("input", "", "input sol file path to generate the enums from")
	flagPackage = flag.String("package", "", "package name to generate the enum in")
	flagOutput  = flag.String("output", "", "output file path to write generated codes")
	flagPrefix  = flag.String("prefix", "", "prefix added to enum type (not instances)")
)

func main() {
	flag.Parse()
	ctx := context.Background()
	if err := run(ctx, *flagInput, *flagPackage, *flagPrefix, *flagOutput); err != nil {
		log.Error(ctx, "Fatal error", err)
	}
}

func run(ctx context.Context, input, pkg, prefix, output string) error {
	log.Debug(ctx, "sol-enum-gen args", "input", input, "package", pkg, "output", output)

	enums, err := parseEnums(input, prefix)
	if err != nil {
		return errors.Wrap(err, "parse enums")
	}

	if len(enums) == 0 {
		log.Info(ctx, "No enums found in input")
		return nil
	}

	log.Debug(ctx, "Generating golang enums", "count", len(enums), "first", enums[0].Type())

	data := Data{
		Package: pkg,
		Enums:   enums,
	}

	return writeTemplate(data, output)
}

func parseEnums(input string, prefix string) ([]EnumType, error) {
	// Open input
	content, err := os.ReadFile(input)
	if err != nil {
		return nil, errors.Wrap(err, "read input")
	}

	var enums []EnumType
	var currentEnum *EnumType

	// Parse enums from input content
	for _, line := range strings.Split(string(content), "\n") {
		line = strings.TrimSpace(line)
		if currentEnum != nil {
			if isEnumEnd(line) {
				enums = append(enums, *currentEnum)
				currentEnum = nil

				continue
			}
			instance := parseEnumInstance(line, *currentEnum)
			currentEnum.Instances = append(currentEnum.Instances, instance)

			continue
		}

		if name, ok := isNewEnum(line); ok {
			currentEnum = &EnumType{
				TypeName:   name,
				TypePrefix: prefix,
			}
		}
	}

	return enums, nil
}

func isEnumEnd(line string) bool {
	return line == "}"
}

func parseEnumInstance(line string, enum EnumType) EnumInstance {
	return EnumInstance{
		TypeName:   enum.TypeName,
		TypePrefix: enum.TypePrefix,
		Name:       enum.TypeName + strings.TrimSuffix(line, ","),
		Value:      uint8(len(enum.Instances)), // 0-indexed
	}
}

func isNewEnum(line string) (string, bool) {
	if strings.HasPrefix(line, "enum ") {
		resp := strings.TrimPrefix(line, "enum ")
		resp = strings.TrimSuffix(resp, "{")
		resp = strings.TrimSpace(resp)

		return resp, true
	}

	return "", false
}

func writeTemplate(data Data, output string) error {
	t, err := template.New("").Parse(tpl)
	if err != nil {
		return errors.Wrap(err, "parse template")
	}

	var b bytes.Buffer
	err = t.Execute(&b, data)
	if err != nil {
		return errors.Wrap(err, "exec template")
	}

	out, err := imports.Process(output, b.Bytes(), nil)
	if err != nil {
		return errors.Wrap(err, "format")
	}

	err = os.WriteFile(output, out, 0o644)
	if err != nil {
		return errors.Wrap(err, "write file")
	}

	return nil
}

type Data struct {
	Package string
	Enums   []EnumType
}

type EnumType struct {
	TypeName   string
	TypePrefix string
	Instances  []EnumInstance
}

func (e EnumType) Type() string {
	return e.TypePrefix + e.TypeName
}

type EnumInstance struct {
	TypeName   string
	TypePrefix string
	Name       string
	Value      uint8
}

func (e EnumInstance) Type() string {
	return e.TypePrefix + e.TypeName
}

var tpl = `package {{ .Package }}

// Code generated by solenumgen. DO NOT EDIT.

{{ range .Enums }}
type {{ .Type }} uint8

const (
{{ range .Instances }} {{ .Name }} {{ .Type }} = {{ .Value }}
{{ end -}}
)
{{ end }}
`
