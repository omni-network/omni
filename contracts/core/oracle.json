{"language":"Solidity","sources":{"src/xchain/FeeOracleV1.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.24;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IFeeOracle } from \"../interfaces/IFeeOracle.sol\";\nimport { IFeeOracleV1 } from \"../interfaces/IFeeOracleV1.sol\";\n\n/**\n * @title FeeOracleV1\n * @notice A simple fee oracle with a fixed fee, controlled by an admin account\n *         Used by OmniPortal to calculate xmsg fees\n */\ncontract FeeOracleV1 is IFeeOracle, IFeeOracleV1, OwnableUpgradeable {\n    /**\n     * @notice Base gas limit for each xmsg.\n     */\n    uint64 public baseGasLimit;\n\n    /**\n     * @notice Base protocol fee for each xmsg.\n     */\n    uint256 public protocolFee;\n\n    /**\n     * @notice Address allowed to set gas prices and to-native conversion rates.\n     */\n    address public manager;\n\n    /**\n     * @notice Fee parameters for a specific chain, by chain ID.\n     */\n    mapping(uint64 => IFeeOracleV1.ChainFeeParams) internal _feeParams;\n\n    /**\n     * @notice Denominator for conversion rate calculations.\n     */\n    uint256 public constant CONVERSION_RATE_DENOM = 1e6;\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"FeeOracleV1: not manager\");\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address owner_,\n        address manager_,\n        uint64 baseGasLimit_,\n        uint256 protocolFee_,\n        ChainFeeParams[] calldata params\n    ) public initializer {\n        __Ownable_init(owner_);\n\n        _setManager(manager_);\n        _setBaseGasLimit(baseGasLimit_);\n        _setProtocolFee(protocolFee_);\n        _bulkSetFeeParams(params);\n    }\n\n    /// @inheritdoc IFeeOracle\n    function version() external pure override returns (uint64) {\n        return 1;\n    }\n\n    /// @inheritdoc IFeeOracle\n    function feeFor(uint64 destChainId, bytes calldata data, uint64 gasLimit) external view returns (uint256) {\n        IFeeOracleV1.ChainFeeParams storage execP = _feeParams[destChainId];\n        IFeeOracleV1.ChainFeeParams storage dataP = _feeParams[execP.postsTo];\n\n        uint256 execGasPrice = execP.gasPrice * execP.toNativeRate / CONVERSION_RATE_DENOM;\n        uint256 dataGasPrice = dataP.gasPrice * dataP.toNativeRate / CONVERSION_RATE_DENOM;\n\n        require(execGasPrice > 0, \"FeeOracleV1: no fee params\");\n        require(dataGasPrice > 0, \"FeeOracleV1: no fee params\");\n\n        // 16 gas per non-zero byte, assume non-zero bytes\n        // TODO: given we mostly support rollups that post data to L1, it may be cheaper for users to count\n        //       non-zero bytes (consuming L2 execution gas) to reduce their L1 data fee\n        uint256 dataGas = data.length * 16;\n\n        return protocolFee + (baseGasLimit + gasLimit) * execGasPrice + (dataGas * dataGasPrice);\n    }\n\n    /**\n     * @notice Returns the fee parameters for a destination chain.\n     */\n    function feeParams(uint64 chainId) external view returns (ChainFeeParams memory) {\n        return _feeParams[chainId];\n    }\n\n    /**\n     * @notice Returns the gas price for a destination chain.\n     */\n    function gasPriceOn(uint64 chainId) external view returns (uint256) {\n        return _feeParams[chainId].gasPrice;\n    }\n\n    /**\n     * @notice Returns the to-native conversion rate for a destination chain.\n     */\n    function toNativeRate(uint64 chainId) external view returns (uint256) {\n        return _feeParams[chainId].toNativeRate;\n    }\n\n    /**\n     * @notice Returns the chainId of the chain that the given destination chain posts tx data to.\n     *         For rollups, this is L1.\n     */\n    function postsTo(uint64 chainId) external view returns (uint64) {\n        return _feeParams[chainId].postsTo;\n    }\n\n    /**\n     * @notice Set the fee parameters for a list of destination chains.\n     */\n    function bulkSetFeeParams(ChainFeeParams[] calldata params) external onlyManager {\n        _bulkSetFeeParams(params);\n    }\n\n    /**\n     * @notice Set the gas price for a destination chain.\n     */\n    function setGasPrice(uint64 chainId, uint256 gasPrice) external onlyManager {\n        _setGasPrice(chainId, gasPrice);\n    }\n\n    /**\n     * @notice Set the to native conversion rate for a destination chain.\n     */\n    function setToNativeRate(uint64 chainId, uint256 rate) external onlyManager {\n        _setToNativeRate(chainId, rate);\n    }\n\n    /**\n     * @notice Set the base gas limit for each xmsg.\n     */\n    function setBaseGasLimit(uint64 gasLimit) external onlyOwner {\n        _setBaseGasLimit(gasLimit);\n    }\n\n    /**\n     * @notice Set the base protocol fee for each xmsg.\n     */\n    function setProtocolFee(uint256 fee) external onlyOwner {\n        _setProtocolFee(fee);\n    }\n\n    /**\n     * @notice Set the manager admin account.\n     */\n    function setManager(address manager_) external onlyOwner {\n        require(manager_ != address(0), \"FeeOracleV1: no zero manager\");\n        _setManager(manager_);\n    }\n\n    /**\n     * @notice Set the fee parameters for a list of destination chains.\n     */\n    function _bulkSetFeeParams(ChainFeeParams[] calldata params) internal {\n        for (uint256 i = 0; i < params.length; i++) {\n            ChainFeeParams memory p = params[i];\n\n            require(p.gasPrice > 0, \"FeeOracleV1: no zero gas price\");\n            require(p.toNativeRate > 0, \"FeeOracleV1: no zero rate\");\n            require(p.chainId != 0, \"FeeOracleV1: no zero chain id\");\n            require(p.postsTo != 0, \"FeeOracleV1: no zero postsTo\");\n\n            _feeParams[p.chainId] = p;\n\n            emit FeeParamsSet(p.chainId, p.postsTo, p.gasPrice, p.toNativeRate);\n        }\n    }\n\n    /**\n     * @notice Set the gas price for a destination chain.\n     */\n    function _setGasPrice(uint64 chainId, uint256 gasPrice) internal {\n        require(gasPrice > 0, \"FeeOracleV1: no zero gas price\");\n        require(chainId != 0, \"FeeOracleV1: no zero chain id\");\n\n        _feeParams[chainId].gasPrice = gasPrice;\n        emit GasPriceSet(chainId, gasPrice);\n    }\n\n    /**\n     * @notice Set the to-native conversion rate for a destination chain.\n     */\n    function _setToNativeRate(uint64 chainId, uint256 rate) internal {\n        require(rate > 0, \"FeeOracleV1: no zero rate\");\n        require(chainId != 0, \"FeeOracleV1: no zero chain id\");\n\n        _feeParams[chainId].toNativeRate = rate;\n        emit ToNativeRateSet(chainId, rate);\n    }\n\n    /**\n     * @notice Set the base gas limit for each xmsg.\n     */\n    function _setBaseGasLimit(uint64 gasLimit) internal {\n        baseGasLimit = gasLimit;\n        emit BaseGasLimitSet(gasLimit);\n    }\n\n    /**\n     * @notice Set the base protocol fee for each xmsg.\n     */\n    function _setProtocolFee(uint256 fee) internal {\n        protocolFee = fee;\n        emit ProtocolFeeSet(fee);\n    }\n\n    /**\n     * @notice Set the manager admin account.\n     */\n    function _setManager(address manager_) internal {\n        manager = manager_;\n        emit ManagerSet(manager_);\n    }\n}\n"},"node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"src/interfaces/IFeeOracle.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * @title IFeeOracle\n * @notice Defines the interface expected of a fee oracle by the OmniPortal\n */\ninterface IFeeOracle {\n    /**\n     * @notice Calculate the fee for calling a contract on another chain\n     * @dev Fees denominated in wei\n     * @param destChainId Destination chain ID\n     * @param data Encoded function calldata\n     * @param gasLimit Execution gas limit, enforced on destination chain\n     */\n    function feeFor(uint64 destChainId, bytes calldata data, uint64 gasLimit) external view returns (uint256);\n\n    /**\n     * @notice Returns the version of the fee oracle\n     */\n    function version() external view returns (uint64);\n}\n"},"src/interfaces/IFeeOracleV1.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport { IFeeOracle } from \"./IFeeOracle.sol\";\nimport { IConversionRateOracle } from \"./IConversionRateOracle.sol\";\n\n/**\n * @title IFeeOracleV1\n * @notice Extends IFeeOracle with FeeOracleV1 methods\n */\ninterface IFeeOracleV1 is IFeeOracle, IConversionRateOracle {\n    /**\n     * @notice Emitted when fee parameters for a chain are set.\n     */\n    event FeeParamsSet(uint64 chainId, uint64 postsTo, uint256 gasPrice, uint256 toNativeRate);\n\n    /**\n     * @notice Emitted when the base gas limit is set.\n     */\n    event BaseGasLimitSet(uint64 baseGasLimit);\n\n    /**\n     * @notice Emitted when the base protocol fee is set.\n     */\n    event ProtocolFeeSet(uint256 protocolFee);\n\n    /**\n     * @notice Emitted when the gas price for a destination chain is set.\n     */\n    event GasPriceSet(uint64 chainId, uint256 gasPrice);\n\n    /**\n     * @notice Emitted when the to-native conversion rate for a destination chain is set.\n     */\n    event ToNativeRateSet(uint64 chainId, uint256 toNativeRate);\n\n    /**\n     * @notice Emitted when the manager is changed.\n     */\n    event ManagerSet(address manager);\n\n    /**\n     * @notice Fee parameters for a specific chain.\n     * @custom:field chainId        The chain ID.\n     * @custom:field postTo         The chain ID to which this chain posts tx calldata, used to calculate\n     *                              calldata fees. For non-rollups, this should be the same as chainId.\n     * @custom:field gasPrice       The gas price on that chain (denominated in chains native token).\n     * @custom:field toNativeRate   The conversion rate from the chains native token to this chain's\n     *                              native token. Rate is numerator over CONVERSION_RATE_DENOM.\n     */\n    struct ChainFeeParams {\n        uint64 chainId;\n        uint64 postsTo;\n        uint256 gasPrice;\n        uint256 toNativeRate;\n    }\n\n    /**\n     * @notice Set the fee parameters for a list of destination chains.\n     */\n    function bulkSetFeeParams(ChainFeeParams[] calldata params) external;\n\n    /**\n     * @notice Set the gas price for a destination chain.\n     */\n    function setGasPrice(uint64 chainId, uint256 gasPrice) external;\n\n    /**\n     * @notice Set the to native conversion rate for a destination chain.\n     */\n    function setToNativeRate(uint64 chainId, uint256 toNativeRate) external;\n\n    /**\n     * @notice Set the base gas limit for each xmsg.\n     */\n    function setBaseGasLimit(uint64 gasLimit) external;\n\n    /**\n     * @notice Set the base protocol fee for each xmsg.\n     */\n    function setProtocolFee(uint256 fee) external;\n\n    /**\n     * @notice Set the manager admin account.\n     */\n    function setManager(address manager_) external;\n}\n"},"node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"},"src/interfaces/IConversionRateOracle.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * @title IConversionRateOracle\n * @notice Provides conversion rate from other chain's native token to this chain's native token.\n */\ninterface IConversionRateOracle {\n    /**\n     * @notice Returns the conversion rate (as a numerator over CONVERSION_RATE_DENOM) from `chainId`'s\n     *         native token to this chain's native token.\n     */\n    function toNativeRate(uint64 chainId) external view returns (uint256);\n\n    /**\n     * @notice Denominator used in to conversion rate calculations.\n     */\n    function CONVERSION_RATE_DENOM() external view returns (uint256);\n}\n"}},"settings":{"remappings":["forge-std/=node_modules/forge-std/src/","ds-test/=node_modules/ds-test/src/","src/=src/","test/=test/","avs/=../avs/src/","@openzeppelin-upgrades/contracts/=node_modules/@openzeppelin/contracts-upgradeable/","@nomad-xyz/=node_modules/@nomad-xyz/","@openzeppelin-v4/=node_modules/@openzeppelin-v4/","@openzeppelin/=node_modules/@openzeppelin/","eigenlayer-contracts/=node_modules/eigenlayer-contracts/","eigenlayer-middleware/=node_modules/eigenlayer-middleware/","multiproof/=node_modules/multiproof/","solmate/=node_modules/solmate/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
