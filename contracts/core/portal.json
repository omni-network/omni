{"language":"Solidity","sources":{"src/xchain/OmniPortal.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.24;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { ExcessivelySafeCall } from \"@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol\";\n\nimport { IFeeOracle } from \"../interfaces/IFeeOracle.sol\";\nimport { IOmniPortal } from \"../interfaces/IOmniPortal.sol\";\nimport { IOmniPortalSys } from \"../interfaces/IOmniPortalSys.sol\";\nimport { IOmniPortalAdmin } from \"../interfaces/IOmniPortalAdmin.sol\";\nimport { XBlockMerkleProof } from \"../libraries/XBlockMerkleProof.sol\";\nimport { XTypes } from \"../libraries/XTypes.sol\";\nimport { Quorum } from \"../libraries/Quorum.sol\";\nimport { ConfLevel } from \"../libraries/ConfLevel.sol\";\nimport { PausableUpgradeable } from \"../utils/PausableUpgradeable.sol\";\n\nimport { OmniPortalConstants } from \"./OmniPortalConstants.sol\";\nimport { OmniPortalStorage } from \"./OmniPortalStorage.sol\";\n\ncontract OmniPortal is\n    IOmniPortal,\n    IOmniPortalSys,\n    IOmniPortalAdmin,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OmniPortalConstants,\n    OmniPortalStorage\n{\n    using ExcessivelySafeCall for address;\n\n    /**\n     * @notice Modifier that requires an action is not paused. An action is paused if:\n     *          - actionId is paused for all chains\n     *          - actionId is paused for chainId\n     *          - All actions are paused\n     *         Available actions are ActionXCall and ActionXSubmit, defined in OmniPortalConstants.sol.\n     */\n    modifier whenNotPaused(bytes32 actionId, uint64 chainId_) {\n        require(!_isPaused(actionId, _chainActionId(actionId, chainId_)), \"OmniPortal: paused\");\n        _;\n    }\n\n    /**\n     * @notice Construct the OmniPortal contract\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialization init params\n     * @dev Used to reduce stack depth in initialize()\n     * @custom:field owner                  The owner of the contract\n     * @custom:field feeOracle              Address of the fee oracle contract\n     * @custom:field omniChainId            Chain ID of Omni's EVM execution chain\n     * @custom:field omniCChainId           Chain ID of Omni's consensus chain\n     * @custom:field xmsgMaxGasLimit        Maximum gas limit for xmsg\n     * @custom:field xmsgMinGasLimit        Minimum gas limit for xmsg\n     * @custom:field xmsgMaxDataSize        Maximum size of xmsg data in bytes\n     * @custom:field xreceiptMaxErrorSize   Maximum size of xreceipt error in bytes\n     * @custom:field xsubValsetCutoff       Number of validator sets since the latest that validate an XSubmission\n     * @custom:field cChainXMsgOffset       Offset for xmsgs from the consensus chain\n     * @custom:field cChainXBlockOffset     Offset for xblocks from the consensus chain\n     * @custom:field valSetId               Initial validator set id\n     * @custom:field validators             Initial validator set\n     */\n    struct InitParams {\n        address owner;\n        address feeOracle;\n        uint64 omniChainId;\n        uint64 omniCChainId;\n        uint64 xmsgMaxGasLimit;\n        uint64 xmsgMinGasLimit;\n        uint16 xmsgMaxDataSize;\n        uint16 xreceiptMaxErrorSize;\n        uint8 xsubValsetCutoff;\n        uint64 cChainXMsgOffset;\n        uint64 cChainXBlockOffset;\n        uint64 valSetId;\n        XTypes.Validator[] validators;\n    }\n\n    /**\n     * @notice Initialize the OmniPortal contract\n     */\n    function initialize(InitParams calldata p) public initializer {\n        __Ownable_init(p.owner);\n\n        _setFeeOracle(p.feeOracle);\n        _setXMsgMaxGasLimit(p.xmsgMaxGasLimit);\n        _setXMsgMaxDataSize(p.xmsgMaxDataSize);\n        _setXMsgMinGasLimit(p.xmsgMinGasLimit);\n        _setXReceiptMaxErrorSize(p.xreceiptMaxErrorSize);\n        _setXSubValsetCutoff(p.xsubValsetCutoff);\n        _addValidatorSet(p.valSetId, p.validators);\n\n        omniChainId = p.omniChainId;\n        omniCChainId = p.omniCChainId;\n\n        // omni consensus chain uses Finalised+Broadcast shard\n        uint64 omniCShard = ConfLevel.toBroadcastShard(ConfLevel.Finalized);\n        _setInXMsgOffset(p.omniCChainId, omniCShard, p.cChainXMsgOffset);\n        _setInXBlockOffset(p.omniCChainId, omniCShard, p.cChainXBlockOffset);\n    }\n\n    function chainId() public view returns (uint64) {\n        return uint64(block.chainid);\n    }\n\n    /**\n     * @notice Returns the current network (supported chain IDs and shards)\n     */\n    function network() external view returns (XTypes.Chain[] memory) {\n        return _network;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////\n    //                      Outbound xcall functions                            //\n    //////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Call a contract on another chain.\n     * @param destChainId   Destination chain ID\n     * @param conf          Confirmation level\n     * @param to            Address of contract to call on destination chain\n     * @param data          ABI Encoded function calldata\n     * @param gasLimit      Execution gas limit, enforced on destination chain\n     */\n    function xcall(uint64 destChainId, uint8 conf, address to, bytes calldata data, uint64 gasLimit)\n        external\n        payable\n        whenNotPaused(ActionXCall, destChainId)\n    {\n        require(isSupportedDest[destChainId], \"OmniPortal: unsupported dest\");\n        require(to != VirtualPortalAddress, \"OmniPortal: no portal xcall\");\n        require(gasLimit <= xmsgMaxGasLimit, \"OmniPortal: gasLimit too high\");\n        require(gasLimit >= xmsgMinGasLimit, \"OmniPortal: gasLimit too low\");\n        require(data.length <= xmsgMaxDataSize, \"OmniPortal: data too large\");\n\n        // conf level will always be last byte of shardId. for now, shardId is just conf level\n        uint64 shardId = uint64(conf);\n        require(isSupportedShard[shardId], \"OmniPortal: unsupported shard\");\n\n        uint256 fee = feeFor(destChainId, data, gasLimit);\n        require(msg.value >= fee, \"OmniPortal: insufficient fee\");\n\n        outXMsgOffset[destChainId][shardId] += 1;\n\n        emit XMsg(destChainId, shardId, outXMsgOffset[destChainId][shardId], msg.sender, to, data, gasLimit, fee);\n    }\n\n    /**\n     * @notice Calculate the fee for calling a contract on another chain\n     *         Fees denominated in wei.\n     * @param destChainId   Destination chain ID\n     * @param data          Encoded function calldata\n     * @param gasLimit      Execution gas limit, enforced on destination chain\n     */\n    function feeFor(uint64 destChainId, bytes calldata data, uint64 gasLimit) public view returns (uint256) {\n        return IFeeOracle(feeOracle).feeFor(destChainId, data, gasLimit);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////\n    //                      Inbound xcall functions                             //\n    //////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Submit a batch of XMsgs to be executed on this chain\n     * @param xsub  An xchain submission, including an attestation root w/ validator signatures,\n     *              and a block header and message batch, proven against the attestation root.\n     */\n    function xsubmit(XTypes.Submission calldata xsub)\n        external\n        whenNotPaused(ActionXSubmit, xsub.blockHeader.sourceChainId)\n        nonReentrant\n    {\n        XTypes.Msg[] calldata xmsgs = xsub.msgs;\n        XTypes.BlockHeader calldata xheader = xsub.blockHeader;\n        uint64 valSetId = xsub.validatorSetId;\n\n        require(xheader.consensusChainId == omniCChainId, \"OmniPortal: wrong cchain ID\");\n        require(xmsgs.length > 0, \"OmniPortal: no xmsgs\");\n        require(valSetTotalPower[valSetId] > 0, \"OmniPortal: unknown val set\");\n        require(valSetId >= _minValSet(), \"OmniPortal: old val set\");\n\n        // check that the attestationRoot is signed by a quorum of validators in xsub.validatorsSetId\n        require(\n            Quorum.verify(\n                xsub.attestationRoot,\n                xsub.signatures,\n                valSet[valSetId],\n                valSetTotalPower[valSetId],\n                XSubQuorumNumerator,\n                XSubQuorumDenominator\n            ),\n            \"OmniPortal: no quorum\"\n        );\n\n        // check that blockHeader and xmsgs are included in attestationRoot\n        require(\n            XBlockMerkleProof.verify(xsub.attestationRoot, xheader, xmsgs, xsub.proof, xsub.proofFlags),\n            \"OmniPortal: invalid proof\"\n        );\n\n        // execute xmsgs\n        for (uint256 i = 0; i < xmsgs.length; i++) {\n            _exec(xheader, xmsgs[i]);\n        }\n    }\n\n    /**\n     * @notice Returns the current XMsg being executed via this portal.\n     *          - xmsg().sourceChainId  Chain ID of the source xcall\n     *          - xmsg().sender         msg.sender of the source xcall\n     *         If no XMsg is being executed, all fields will be zero.\n     *          - xmsg().sourceChainId  == 0\n     *          - xmsg().sender         == address(0)\n     */\n    function xmsg() external view returns (XTypes.MsgContext memory) {\n        return _xmsg;\n    }\n\n    /**\n     * @notice Returns true the current transaction is an xcall, false otherwise\n     */\n    function isXCall() external view returns (bool) {\n        return _xmsg.sourceChainId != 0;\n    }\n\n    /**\n     * @notice Execute an xmsg.\n     * @dev Verify if an XMsg is next in its XStream, execute it, increment inXMsgOffset, emit an XReceipt event\n     */\n    function _exec(XTypes.BlockHeader calldata xheader, XTypes.Msg calldata xmsg_) internal {\n        uint64 sourceChainId = xheader.sourceChainId;\n        uint64 destChainId = xmsg_.destChainId;\n        uint64 shardId = xmsg_.shardId;\n        uint64 offset = xmsg_.offset;\n\n        require(destChainId == chainId() || destChainId == BroadcastChainId, \"OmniPortal: wrong dest chain\");\n        require(offset == inXMsgOffset[sourceChainId][shardId] + 1, \"OmniPortal: wrong offset\");\n\n        // verify xmsg conf level matches xheader conf level\n        // allow finalized blocks to for any xmsg, so that finalized blocks may correct \"fuzzy\" xmsgs\n        require(\n            ConfLevel.Finalized == xheader.confLevel || xheader.confLevel == uint8(shardId),\n            \"OmniPortal: wrong conf level\"\n        );\n\n        if (inXBlockOffset[sourceChainId][shardId] < xheader.offset) {\n            inXBlockOffset[sourceChainId][shardId] = xheader.offset;\n        }\n\n        inXMsgOffset[sourceChainId][shardId] += 1;\n\n        // do not allow user xcalls to the portal\n        // only sys xcalls (to _VIRTUAL_PORTAL_ADDRESS) are allowed to be executed on the portal\n        if (xmsg_.to == address(this)) {\n            emit XReceipt(\n                sourceChainId,\n                shardId,\n                offset,\n                0,\n                msg.sender,\n                false,\n                abi.encodeWithSignature(\"Error(string)\", \"OmniPortal: no xcall to portal\")\n            );\n\n            return;\n        }\n\n        // calls to VirtualPortalAddress are syscalls\n        bool isSysCall = xmsg_.to == VirtualPortalAddress;\n\n        if (isSysCall) {\n            bytes4 selector = bytes4(xmsg_.data);\n\n            // sys calls must broadcast from the consensus chain to a supported handler\n            require(\n                xheader.sourceChainId == omniCChainId && xmsg_.sender == CChainSender\n                    && xmsg_.destChainId == BroadcastChainId\n                    && xmsg_.shardId == ConfLevel.toBroadcastShard(ConfLevel.Finalized)\n                    && (selector == this.addValidatorSet.selector || selector == this.setNetwork.selector),\n                \"OmniPortal: invalid syscall\"\n            );\n        } else {\n            // only sys calls can be broadcast from the consensus chain\n            require(\n                xheader.sourceChainId != omniCChainId && xmsg_.sender != CChainSender\n                    && xmsg_.destChainId != BroadcastChainId\n                    && xmsg_.shardId != ConfLevel.toBroadcastShard(ConfLevel.Finalized),\n                \"OmniPortal: invalid xcall\"\n            );\n        }\n\n        // set _xmsg to the one we're executing, allowing external contracts to query the current xmsg via xmsg()\n        _xmsg = XTypes.MsgContext(sourceChainId, xmsg_.sender);\n\n        (bool success, bytes memory result, uint256 gasUsed) =\n            isSysCall ? _syscall(xmsg_.data) : _call(xmsg_.to, xmsg_.gasLimit, xmsg_.data);\n\n        // reset xmsg to zero\n        delete _xmsg;\n\n        bytes memory errorMsg = success ? bytes(\"\") : result;\n\n        emit XReceipt(sourceChainId, shardId, offset, gasUsed, msg.sender, success, errorMsg);\n    }\n\n    /**\n     * @notice Call an external contract.\n     * @dev Returns the result of the call, the gas used, and whether the call was successful.\n     * @param to                The address of the contract to call.\n     * @param gasLimit          Gas limit of the call.\n     * @param data              Calldata to send to the contract.\n     */\n    function _call(address to, uint256 gasLimit, bytes calldata data) internal returns (bool, bytes memory, uint256) {\n        uint256 gasLeftBefore = gasleft();\n\n        // use excessivelySafeCall for external calls to prevent large return bytes mem copy\n        (bool success, bytes memory result) =\n            to.excessivelySafeCall({ _gas: gasLimit, _value: 0, _maxCopy: xreceiptMaxErrorSize, _calldata: data });\n\n        uint256 gasLeftAfter = gasleft();\n\n        // Ensure relayer sent enough gas for the call\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bd325d56b4c62c9c5c1aff048c37c6bb18ac0290/contracts/metatx/MinimalForwarder.sol#L58-L68\n        if (gasLeftAfter <= gasLimit / 63) {\n            // We use invalid opcode to consume all gas and bubble-up the effects, to emulate an \"OutOfGas\" exception\n            assembly {\n                invalid()\n            }\n        }\n\n        return (success, result, gasLeftBefore - gasLeftAfter);\n    }\n\n    /**\n     * @notice Call a function on the current contract.\n     * @dev Reverts on failure. We match _call() return signature for symmetry.\n     * @param data      Calldata to execute on the current contract.\n     */\n    function _syscall(bytes calldata data) internal returns (bool, bytes memory, uint256) {\n        uint256 gasUsed = gasleft();\n        (bool success, bytes memory result) = address(this).call(data);\n        gasUsed = gasUsed - gasleft();\n\n        // if not success, revert with same reason\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        return (success, result, gasUsed);\n    }\n\n    /**\n     * @notice Returns the minimum validator set id that can be used for xsubmissions\n     */\n    function _minValSet() internal view returns (uint64) {\n        return latestValSetId > xsubValsetCutoff\n            // plus 1, so the number of accepted valsets == XSubValsetCutoff\n            ? (latestValSetId - xsubValsetCutoff + 1)\n            : 1;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////\n    //                          Syscall functions                               //\n    //////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Add a new validator set.\n     * @dev Only callable via xcall from Omni's consensus chain\n     * @param valSetId      Validator set id\n     * @param validators    Validator set\n     */\n    function addValidatorSet(uint64 valSetId, XTypes.Validator[] calldata validators) external {\n        require(msg.sender == address(this), \"OmniPortal: only self\");\n        require(_xmsg.sourceChainId == omniCChainId, \"OmniPortal: only cchain\");\n        require(_xmsg.sender == CChainSender, \"OmniPortal: only cchain sender\");\n        _addValidatorSet(valSetId, validators);\n    }\n\n    /**\n     * @notice Add a new validator set\n     * @param valSetId      Validator set id\n     * @param validators    Validator set\n     */\n    function _addValidatorSet(uint64 valSetId, XTypes.Validator[] calldata validators) internal {\n        uint256 numVals = validators.length;\n        require(numVals > 0, \"OmniPortal: no validators\");\n        require(valSetTotalPower[valSetId] == 0, \"OmniPortal: duplicate val set\");\n\n        uint64 totalPower;\n        XTypes.Validator memory val;\n        mapping(address => uint64) storage _valSet = valSet[valSetId];\n\n        for (uint256 i = 0; i < numVals; i++) {\n            val = validators[i];\n\n            require(val.addr != address(0), \"OmniPortal: no zero validator\");\n            require(val.power > 0, \"OmniPortal: no zero power\");\n            require(_valSet[val.addr] == 0, \"OmniPortal: duplicate validator\");\n\n            totalPower += val.power;\n            _valSet[val.addr] = val.power;\n        }\n\n        valSetTotalPower[valSetId] = totalPower;\n\n        if (valSetId > latestValSetId) latestValSetId = valSetId;\n\n        emit ValidatorSetAdded(valSetId);\n    }\n\n    /**\n     * @notice Set the network of supported chains & shards\n     * @dev Only callable via xcall from Omni's consensus chain\n     * @param network_  The new network\n     */\n    function setNetwork(XTypes.Chain[] calldata network_) external {\n        require(msg.sender == address(this), \"OmniPortal: only self\");\n        require(_xmsg.sourceChainId == omniCChainId, \"OmniPortal: only cchain\");\n        require(_xmsg.sender == CChainSender, \"OmniPortal: only cchain sender\");\n        _setNetwork(network_);\n    }\n\n    /**\n     * @notice Set the network of supported chains & shards\n     * @param network_  The new network\n     */\n    function _setNetwork(XTypes.Chain[] calldata network_) internal {\n        _clearNetwork();\n\n        XTypes.Chain calldata c;\n        for (uint256 i = 0; i < network_.length; i++) {\n            c = network_[i];\n            _network.push(c);\n\n            // if not this chain, mark as supported dest\n            if (c.chainId != chainId()) {\n                isSupportedDest[c.chainId] = true;\n                continue;\n            }\n\n            // if this chain, mark shards as supported\n            for (uint256 j = 0; j < c.shards.length; j++) {\n                isSupportedShard[c.shards[j]] = true;\n            }\n        }\n    }\n\n    /**\n     * @notice Clear the network of supported chains & shards\n     */\n    function _clearNetwork() private {\n        XTypes.Chain storage c;\n        for (uint256 i = 0; i < _network.length; i++) {\n            c = _network[i];\n\n            // if not this chain, mark as unsupported dest\n            if (c.chainId != chainId()) {\n                isSupportedDest[c.chainId] = false;\n                continue;\n            }\n\n            // if this chain, mark shards as unsupported\n            for (uint256 j = 0; j < c.shards.length; j++) {\n                isSupportedShard[c.shards[j]] = false;\n            }\n        }\n\n        delete _network;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////\n    //                          Admin functions                                 //\n    //////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Set the inbound xmsg offset for a chain and shard\n     * @param sourceChainId    Source chain ID\n     * @param shardId          Shard ID\n     * @param offset           New xmsg offset\n     */\n    function setInXMsgOffset(uint64 sourceChainId, uint64 shardId, uint64 offset) external onlyOwner {\n        _setInXMsgOffset(sourceChainId, shardId, offset);\n    }\n\n    /**\n     * @notice Set the inbound xblock offset for a chain and shard\n     * @param sourceChainId    Source chain ID\n     * @param shardId          Shard ID\n     * @param offset           New xblock offset\n     */\n    function setInXBlockOffset(uint64 sourceChainId, uint64 shardId, uint64 offset) external onlyOwner {\n        _setInXBlockOffset(sourceChainId, shardId, offset);\n    }\n\n    /**\n     * @notice Set the fee oracle\n     */\n    function setFeeOracle(address feeOracle_) external onlyOwner {\n        _setFeeOracle(feeOracle_);\n    }\n\n    /**\n     * @notice Transfer all collected fees to the give address\n     * @param to    The address to transfer the fees to\n     */\n    function collectFees(address to) external onlyOwner {\n        uint256 amount = address(this).balance;\n\n        // .transfer() is fine, owner should provide an EOA address that will not\n        // consume more than 2300 gas on transfer, and we are okay .transfer() reverts\n        payable(to).transfer(amount);\n\n        emit FeesCollected(to, amount);\n    }\n\n    /**\n     * @notice Set the minimum gas limit for xmsg\n     */\n    function setXMsgMinGasLimit(uint64 gasLimit) external onlyOwner {\n        _setXMsgMinGasLimit(gasLimit);\n    }\n\n    /**\n     * @notice Set the maximum gas limit for xmsg\n     */\n    function setXMsgMaxGasLimit(uint64 gasLimit) external onlyOwner {\n        _setXMsgMaxGasLimit(gasLimit);\n    }\n\n    /**\n     * @notice Set the maximum error bytes for xreceipt\n     */\n    function setXMsgMaxDataSize(uint16 numBytes) external onlyOwner {\n        _setXMsgMaxDataSize(numBytes);\n    }\n\n    /**\n     * @notice Set the maximum error bytes for xreceipt\n     */\n    function setXReceiptMaxErrorSize(uint16 numBytes) external onlyOwner {\n        _setXReceiptMaxErrorSize(numBytes);\n    }\n\n    /**\n     * @notice Set the number of validator sets since the latest that can validate an XSubmission\n     */\n    function setXSubValsetCutoff(uint8 xsubValsetCutoff_) external onlyOwner {\n        _setXSubValsetCutoff(xsubValsetCutoff_);\n    }\n\n    /**\n     * @notice Pause xcalls and xsubissions from all chains\n     */\n    function pause() external onlyOwner {\n        _pauseAll();\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpause xcalls and xsubissions from all chains\n     */\n    function unpause() external onlyOwner {\n        _unpauseAll();\n        emit Unpaused();\n    }\n\n    /**\n     * @notice Pause xcalls to all chains\n     */\n    function pauseXCall() external onlyOwner {\n        _pause(ActionXCall);\n        emit XCallPaused();\n    }\n\n    /**\n     * @notice Unpause xcalls to all chains\n     */\n    function unpauseXCall() external onlyOwner {\n        _unpause(ActionXCall);\n        emit XCallUnpaused();\n    }\n\n    /**\n     * @notice Pause xcalls to a specific chain\n     * @param chainId_   Destination chain ID\n     */\n    function pauseXCallTo(uint64 chainId_) external onlyOwner {\n        _pause(_chainActionId(ActionXCall, chainId_));\n        emit XCallToPaused(chainId_);\n    }\n\n    /**\n     * @notice Unpause xcalls to a specific chain\n     * @param chainId_   Destination chain ID\n     */\n    function unpauseXCallTo(uint64 chainId_) external onlyOwner {\n        _unpause(_chainActionId(ActionXCall, chainId_));\n        emit XCallToUnpaused(chainId_);\n    }\n\n    /**\n     * @notice Pause xsubmissions from all chains\n     */\n    function pauseXSubmit() external onlyOwner {\n        _pause(ActionXSubmit);\n        emit XSubmitPaused();\n    }\n\n    /**\n     * @notice Unpause xsubmissions from all chains\n     */\n    function unpauseXSubmit() external onlyOwner {\n        _unpause(ActionXSubmit);\n        emit XSubmitUnpaused();\n    }\n\n    /**\n     * @notice Pause xsubmissions from a specific chain\n     * @param chainId_    Source chain ID\n     */\n    function pauseXSubmitFrom(uint64 chainId_) external onlyOwner {\n        _pause(_chainActionId(ActionXSubmit, chainId_));\n        emit XSubmitFromPaused(chainId_);\n    }\n\n    /**\n     * @notice Unpause xsubmissions from a specific chain\n     * @param chainId_    Source chain ID\n     */\n    function unpauseXSubmitFrom(uint64 chainId_) external onlyOwner {\n        _unpause(_chainActionId(ActionXSubmit, chainId_));\n        emit XSubmitFromUnpaused(chainId_);\n    }\n\n    /**\n     * @notice Return true if actionId for is paused for the given chain\n     */\n    function isPaused(bytes32 actionId, uint64 chainId_) external view returns (bool) {\n        return _isPaused(actionId, _chainActionId(actionId, chainId_));\n    }\n\n    /**\n     * @notice Return true if actionId is paused for all chains\n     */\n    function isPaused(bytes32 actionId) external view returns (bool) {\n        return _isPaused(actionId);\n    }\n\n    /*\n    * @notice Return true if all actions are paused\n     */\n    function isPaused() external view returns (bool) {\n        return _isAllPaused();\n    }\n\n    /**\n     * @notice An action id with a qualifiying chain id, used as pause keys.\n     */\n    function _chainActionId(bytes32 actionId, uint64 chainId_) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(actionId, chainId_));\n    }\n\n    /**\n     * @notice Set the minimum gas limit for xmsg\n     */\n    function _setXMsgMinGasLimit(uint64 gasLimit) internal {\n        require(gasLimit > 0, \"OmniPortal: no zero min gas\");\n        require(gasLimit < xmsgMaxGasLimit, \"OmniPortal: not below max\");\n        xmsgMinGasLimit = gasLimit;\n        emit XMsgMinGasLimitSet(gasLimit);\n    }\n\n    /**\n     * @notice Set the maximum gas limit for xmsg\n     */\n    function _setXMsgMaxGasLimit(uint64 gasLimit) internal {\n        require(gasLimit > xmsgMinGasLimit, \"OmniPortal: not above min\");\n        xmsgMaxGasLimit = gasLimit;\n        emit XMsgMaxGasLimitSet(gasLimit);\n    }\n\n    /**\n     * @notice Set the maximum data bytes for xmsg\n     */\n    function _setXMsgMaxDataSize(uint16 numBytes) internal {\n        require(numBytes > 0, \"OmniPortal: no zero max size\");\n        xmsgMaxDataSize = numBytes;\n        emit XMsgMaxDataSizeSet(numBytes);\n    }\n\n    /**\n     * @notice Set the maximum error bytes for xreceipt\n     */\n    function _setXReceiptMaxErrorSize(uint16 numBytes) internal {\n        require(numBytes > 0, \"OmniPortal: no zero max size\");\n        xreceiptMaxErrorSize = numBytes;\n        emit XReceiptMaxErrorSizeSet(numBytes);\n    }\n\n    /**\n     * @notice Set the number of validator sets since the latest that can validate an XSubmission\n     */\n    function _setXSubValsetCutoff(uint8 xsubValsetCutoff_) internal {\n        require(xsubValsetCutoff_ > 0, \"OmniPortal: no zero cutoff\");\n        xsubValsetCutoff = xsubValsetCutoff_;\n        emit XSubValsetCutoffSet(xsubValsetCutoff_);\n    }\n\n    /**\n     * @notice Set the fee oracle\n     */\n    function _setFeeOracle(address feeOracle_) internal {\n        require(feeOracle_ != address(0), \"OmniPortal: no zero feeOracle\");\n        feeOracle = feeOracle_;\n        emit FeeOracleSet(feeOracle_);\n    }\n\n    /**\n     * @notice Set the inbound xmsg offset for a chain and shard\n     */\n    function _setInXMsgOffset(uint64 sourceChainId, uint64 shardId, uint64 offset) internal {\n        inXMsgOffset[sourceChainId][shardId] = offset;\n        emit InXMsgOffsetSet(sourceChainId, shardId, offset);\n    }\n\n    /**\n     * @notice Set the inbound xblock offset for a chain and shard\n     */\n    function _setInXBlockOffset(uint64 sourceChainId, uint64 shardId, uint64 offset) internal {\n        inXBlockOffset[sourceChainId][shardId] = offset;\n        emit InXBlockOffsetSet(sourceChainId, shardId, offset);\n    }\n}\n"},"node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"node_modules/@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"},"node_modules/@nomad-xyz/excessively-safe-call/src/ExcessivelySafeCall.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n        internal\n        pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"},"src/interfaces/IFeeOracle.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * @title IFeeOracle\n * @notice Defines the interface expected of a fee oracle by the OmniPortal\n */\ninterface IFeeOracle {\n    /**\n     * @notice Calculate the fee for calling a contract on another chain\n     * @dev Fees denominated in wei\n     * @param destChainId Destination chain ID\n     * @param data Encoded function calldata\n     * @param gasLimit Execution gas limit, enforced on destination chain\n     */\n    function feeFor(uint64 destChainId, bytes calldata data, uint64 gasLimit) external view returns (uint256);\n\n    /**\n     * @notice Returns the version of the fee oracle\n     */\n    function version() external view returns (uint64);\n}\n"},"src/interfaces/IOmniPortal.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport { XTypes } from \"../libraries/XTypes.sol\";\n\n/**\n * @title IOmniPortal\n * @notice The OmniPortal is the on-chain interface to Omni's cross-chain\n *         messaging protocol. It is used to initiate and execute cross-chain calls.\n */\ninterface IOmniPortal {\n    /**\n     * @notice Emitted when an xcall is made to a contract on another chain\n     * @param destChainId   Destination chain ID\n     * @param offset        Offset this XMsg in the source -> dest XStream\n     * @param sender        msg.sender of the source xcall\n     * @param to            Address of the contract to call on the destination chain\n     * @param data          Encoded function calldata\n     * @param gasLimit      Gas limit for execution on destination chain\n     * @param fees          Fees paid for the xcall\n     */\n    event XMsg(\n        uint64 indexed destChainId,\n        uint64 indexed shardId,\n        uint64 indexed offset,\n        address sender,\n        address to,\n        bytes data,\n        uint64 gasLimit,\n        uint256 fees\n    );\n\n    /**\n     * @notice Emitted when an XMsg is executed on its destination chain\n     * @param sourceChainId Source chain ID\n     * @param shardId       Shard ID of the XStream (last byte is the confirmation level)\n     * @param offset        Offset the XMsg in the source -> dest XStream\n     * @param gasUsed       Gas used in execution of the XMsg\n     * @param relayer       Address of the relayer who submitted the XMsg\n     * @param success       Whether the execution succeeded\n     * @param err           Result of XMsg execution, if success == false. Limited to\n     *                      xreceiptMaxErrorBytes(). Empty if success == true.\n     */\n    event XReceipt(\n        uint64 indexed sourceChainId,\n        uint64 indexed shardId,\n        uint64 indexed offset,\n        uint256 gasUsed,\n        address relayer,\n        bool success,\n        bytes err\n    );\n\n    /**\n     * @notice Maximum allowed xmsg gas limit\n     */\n    function xmsgMaxGasLimit() external view returns (uint64);\n\n    /**\n     * @notice Minimum allowed xmsg gas limit\n     */\n    function xmsgMinGasLimit() external view returns (uint64);\n\n    /**\n     * @notice Maximum number of bytes allowed in xmsg data\n     */\n    function xmsgMaxDataSize() external view returns (uint16);\n\n    /**\n     * @notice Maxium number of bytes allowed in xreceipt result\n     */\n    function xreceiptMaxErrorSize() external view returns (uint16);\n\n    /**\n     * @notice Returns the fee oracle address\n     */\n    function feeOracle() external view returns (address);\n\n    /**\n     * @notice Returns the chain ID of the chain to which this portal is deployed\n     */\n    function chainId() external view returns (uint64);\n\n    /**\n     * @notice Returns the chain ID of Omni's EVM execution chain\n     */\n    function omniChainId() external view returns (uint64);\n\n    /**\n     * @notice Returns the offset of the last outbound XMsg sent to destChainId in shardId\n     */\n    function outXMsgOffset(uint64 destChainId, uint64 shardId) external view returns (uint64);\n\n    /**\n     * @notice Returns the offset of the last inbound XMsg received from srcChainId in shardId\n     */\n    function inXMsgOffset(uint64 srcChainId, uint64 shardId) external view returns (uint64);\n\n    /**\n     * @notice Returns the offset of the last inbound XBlock received from srcChainId in shardId\n     */\n    function inXBlockOffset(uint64 srcChainId, uint64 shardId) external view returns (uint64);\n\n    /**\n     * @notice Returns the current XMsg being executed via this portal.\n     *          - xmsg().sourceChainId  Chain ID of the source xcall\n     *          - xmsg().sender         msg.sender of the source xcall\n     *         If no XMsg is being executed, all fields will be zero.\n     *          - xmsg().sourceChainId  == 0\n     *          - xmsg().sender         == address(0)\n     */\n    function xmsg() external view returns (XTypes.MsgContext memory);\n\n    /**\n     * @notice Returns true the current transaction is an xcall, false otherwise\n     */\n    function isXCall() external view returns (bool);\n\n    /**\n     * @notice Returns the shard ID is supported by this portal\n     */\n    function isSupportedShard(uint64 shardId) external view returns (bool);\n\n    /**\n     * @notice Returns the destination chain ID is supported by this portal\n     */\n    function isSupportedDest(uint64 destChainId) external view returns (bool);\n\n    /**\n     * @notice Calculate the fee for calling a contract on another chain\n     *         Fees denominated in wei.\n     * @param destChainId   Destination chain ID\n     * @param data          Encoded function calldata\n     * @param gasLimit      Execution gas limit, enforced on destination chain\n     */\n    function feeFor(uint64 destChainId, bytes calldata data, uint64 gasLimit) external view returns (uint256);\n\n    /**\n     * @notice Call a contract on another chain.\n     * @param destChainId   Destination chain ID\n     * @param conf          Confirmation level;\n     * @param to            Address of contract to call on destination chain\n     * @param data          ABI Encoded function calldata\n     * @param gasLimit      Execution gas limit, enforced on destination chain\n     */\n    function xcall(uint64 destChainId, uint8 conf, address to, bytes calldata data, uint64 gasLimit) external payable;\n\n    /**\n     * @notice Submit a batch of XMsgs to be executed on this chain\n     * @param xsub  An xchain submisison, including an attestation root w/ validator signatures,\n     *              and a block header and message batch, proven against the attestation root.\n     */\n    function xsubmit(XTypes.Submission calldata xsub) external;\n\n    /**\n     * @notice Returns the current network (supported chain IDs and shards)\n     */\n    function network() external view returns (XTypes.Chain[] memory);\n}\n"},"src/interfaces/IOmniPortalSys.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport { XTypes } from \"../libraries/XTypes.sol\";\n\n/**\n * @title IOmniPortalSys\n * @notice Defines syscall functions internal to Omni's cross-chain messaging protocol\n */\ninterface IOmniPortalSys {\n    /**\n     * @notice Emitted when a new validator set is added\n     * @param setId Validator set ID\n     */\n    event ValidatorSetAdded(uint64 indexed setId);\n\n    /**\n     * @notice Add a new validator set.\n     * @dev Only callable via xcall from Omni's consensus chain\n     * @param valSetId      Validator set id\n     * @param validators    Validator set\n     */\n    function addValidatorSet(uint64 valSetId, XTypes.Validator[] calldata validators) external;\n\n    /**\n     * @notice Set the network of supported chains & shards\n     * @dev Only callable via xcall from Omni's consensus chain\n     * @param network_  The new network\n     */\n    function setNetwork(XTypes.Chain[] calldata network_) external;\n}\n"},"src/interfaces/IOmniPortalAdmin.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * @title IOmniPortalAdmin\n * @notice Defines the OmniPortal admin interface\n */\ninterface IOmniPortalAdmin {\n    /**\n     * @notice Emitted when the fee oracle is updated.\n     * @param oracle  The new fee oracle address\n     */\n    event FeeOracleSet(address oracle);\n\n    /**\n     * @notice Emited when fees are collected\n     * @param to        The address the fees are collected to\n     * @param amount    The amount of fees collected\n     */\n    event FeesCollected(address indexed to, uint256 amount);\n\n    /**\n     * @notice Emitted when xmsgMinGasLimit is updated\n     * @param gasLimit The new xmsgMinGasLimit\n     */\n    event XMsgMinGasLimitSet(uint64 gasLimit);\n\n    /**\n     * @notice Emitted when xmsgMaxGasLimit is updated\n     * @param gasLimit The new xmsgMaxGasLimit\n     */\n    event XMsgMaxGasLimitSet(uint64 gasLimit);\n\n    /**\n     * @notice Emitted when xmsgMaxDataSize is updated\n     * @param size The new max size\n     */\n    event XMsgMaxDataSizeSet(uint16 size);\n\n    /**\n     * @notice Emitted when xreceiptMaxErrorSize is updated\n     * @param size The new max size\n     */\n    event XReceiptMaxErrorSizeSet(uint16 size);\n\n    /**\n     * @notice Emitted when the xsubValsetCutoff is updated\n     * @param cutoff The new cutoff\n     */\n    event XSubValsetCutoffSet(uint8 cutoff);\n\n    /**\n     * @notice Emitted the portal is paused, all xcalls and xsubmissions\n     */\n    event Paused();\n\n    /**\n     * @notice Emitted the portal is unpaused, all xcalls and xsubmissions\n     */\n    event Unpaused();\n\n    /**\n     * @notice Emitted when all xcalls are paused\n     */\n    event XCallPaused();\n\n    /**\n     * @notice Emitted when inbound xmsg offset is updated\n     */\n    event InXMsgOffsetSet(uint64 indexed srcChainId, uint64 indexed shardId, uint64 offset);\n\n    /**\n     * @notice Emitted when all inbound xblock offset is updated\n     */\n    event InXBlockOffsetSet(uint64 indexed srcChainId, uint64 indexed shardId, uint64 offset);\n\n    /**\n     * @notice Emitted when all xcalls are unpaused\n     */\n    event XCallUnpaused();\n\n    /**\n     * @notice Emitted when all xsubmissions are paused\n     */\n    event XSubmitPaused();\n\n    /**\n     * @notice Emitted when all xsubmissions are unpaused\n     */\n    event XSubmitUnpaused();\n\n    /**\n     * @notice Emitted when xcalls to a specific chain are paused\n     * @param chainId   The destination chain\n     */\n    event XCallToPaused(uint64 indexed chainId);\n\n    /**\n     * @notice Emitted when xcalls to a specific chain are unpaused\n     * @param chainId   The destination chain\n     */\n    event XCallToUnpaused(uint64 indexed chainId);\n\n    /**\n     * @notice Emitted when xsubmissions from a specific chain are paused\n     * @param chainId    The source chain\n     */\n    event XSubmitFromPaused(uint64 indexed chainId);\n\n    /**\n     * @notice Emitted when xsubmissions from a specific chain are unpaused\n     * @param chainId    The source chain\n     */\n    event XSubmitFromUnpaused(uint64 indexed chainId);\n\n    /**\n     * @notice Set the inbound xmsg offset for a chain and shard\n     * @param sourceChainId    Source chain ID\n     * @param shardId          Shard ID\n     * @param offset           New xmsg offset\n     */\n    function setInXMsgOffset(uint64 sourceChainId, uint64 shardId, uint64 offset) external;\n\n    /**\n     * @notice Set the inbound xblock offset for a chain and shard\n     * @param sourceChainId    Source chain ID\n     * @param shardId          Shard ID\n     * @param offset           New xblock offset\n     */\n    function setInXBlockOffset(uint64 sourceChainId, uint64 shardId, uint64 offset) external;\n\n    /**\n     * @notice Set the fee oracle\n     */\n    function setFeeOracle(address feeOracle) external;\n\n    /**\n     * @notice Transfer all collected fees to the give address\n     * @param to    The address to transfer the fees to\n     */\n    function collectFees(address to) external;\n\n    /**\n     * @notice Set the minimum gas limit for xmsg\n     */\n    function setXMsgMinGasLimit(uint64 gasLimit) external;\n\n    /**\n     * @notice Set the maximum gas limit for xmsg\n     */\n    function setXMsgMaxGasLimit(uint64 gasLimit) external;\n\n    /**\n     * @notice Set the maximum data bytes for xmsg\n     */\n    function setXMsgMaxDataSize(uint16 numBytes) external;\n\n    /**\n     * @notice Set the maximum error bytes for xreceipt\n     */\n    function setXReceiptMaxErrorSize(uint16 numBytes) external;\n\n    /**\n     * @notice Pause xcalls\n     */\n    function pause() external;\n\n    /**\n     * @notice Unpause xcalls\n     */\n    function unpause() external;\n}\n"},"src/libraries/XBlockMerkleProof.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.24;\n\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { XTypes } from \"./XTypes.sol\";\n\n/**\n * @title XBlockMerkleProof\n * @dev Library for verifying XBlock merkle proofs\n */\nlibrary XBlockMerkleProof {\n    /// @dev Domain separation tag for XBlockHeaders, prepended to leaves before hashing and signing.\n    uint8 internal constant DST_XBLOCK_HEADER = 1;\n\n    /// @dev Domain separation tag for XMsgs, prepended to leaves before hashing and signing.\n    uint8 internal constant DST_XMSG = 2;\n\n    /**\n     * @notice Verifies that the provided xmsgs & multi proof produce an xmsg merkle root that, when\n     *         combined with the xblock header, produces the provided root.\n     * @param root          The root of the nested xblock merkle tree (xblock header + xmsg merkle root).\n     * @param blockHeader   Xblock header.\n     * @param msgs          Xmsgs to verify.\n     * @param msgProof      Xmsg merkle proof.\n     * @param msgProofFlags Xmsg merkle proof flags.\n     * @return              True if the msgs, msg proof & block header are valid, against the provided root.\n     */\n    function verify(\n        bytes32 root,\n        XTypes.BlockHeader calldata blockHeader,\n        XTypes.Msg[] calldata msgs,\n        bytes32[] calldata msgProof,\n        bool[] calldata msgProofFlags\n    ) internal pure returns (bool) {\n        bytes32[] memory rootProof = new bytes32[](1);\n        rootProof[0] = MerkleProof.processMultiProofCalldata(msgProof, msgProofFlags, _msgLeaves(msgs));\n        return MerkleProof.verify(rootProof, root, _blockHeaderLeaf(blockHeader));\n    }\n\n    /// @dev Convert xmsgs to leaf hashes\n    function _msgLeaves(XTypes.Msg[] calldata msgs) private pure returns (bytes32[] memory) {\n        bytes32[] memory leaves = new bytes32[](msgs.length);\n\n        for (uint256 i = 0; i < msgs.length; i++) {\n            leaves[i] = _leafHash(DST_XMSG, abi.encode(msgs[i]));\n        }\n\n        return leaves;\n    }\n\n    /// @dev Convert xblock header to leaf hash\n    function _blockHeaderLeaf(XTypes.BlockHeader calldata blockHeader) private pure returns (bytes32) {\n        return _leafHash(DST_XBLOCK_HEADER, abi.encode(blockHeader));\n    }\n\n    /// @dev Double hash leaves, as recommended by OpenZeppelin, to prevent second preimage attacks\n    ///      Leaves must be double hashed in tree / proof construction\n    ///      Callers must specify the domain separation tag of the leaf, which will be hashed in\n    function _leafHash(uint8 dst, bytes memory leaf) private pure returns (bytes32) {\n        return keccak256(bytes.concat(keccak256(abi.encodePacked(dst, leaf))));\n    }\n}\n"},"src/libraries/XTypes.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * @title XTypes\n * @dev Defines xchain types, core to Omni's xchain messaging protocol. These\n *      types mirror those defined in omni/lib/xchain/types.go.\n */\nlibrary XTypes {\n    /**\n     * @notice A cross chain message - the product of an xcall. This matches the XMsg type used\n     *        throughout Omni's cross-chain messaging protocol. Msg is used to construct and verify\n     *        XSubmission merkle trees / proofs.\n     * @custom:field destChainId    Chain ID of the destination chain\n     * @custom:field shardId        Shard ID of the XStream (last byte is the confirmation level)\n     * @custom:field offset         Monotonically incremented offset of Msg in source -> dest Stream\n     * @custom:field sender         msg.sender of xcall on source chain\n     * @custom:field to             Target address to call on destination chain\n     * @custom:field data           Data to provide to call on destination chain\n     * @custom:field gasLimit       Gas limit to use for call execution on destination chain\n     */\n    struct Msg {\n        uint64 destChainId;\n        uint64 shardId;\n        uint64 offset;\n        address sender;\n        address to;\n        bytes data;\n        uint64 gasLimit;\n    }\n\n    /**\n     * @notice Msg context exposed during its execution to consuming xapps.\n     * @custom:field sourceChainId  Chain ID of the source chain\n     * @custom:field sender         msg.sender of xcall on source chain\n     */\n    struct MsgContext {\n        uint64 sourceChainId;\n        address sender;\n    }\n\n    /**\n     * @notice BlockHeader of an XBlock.\n     * @custom:field sourceChainId      Chain ID of the source chain\n     * @custom:field consensusChainId   Chain ID of the Omni consensus chain\n     * @custom:field confLevel          Confirmation level of the cross chain block\n     * @custom:field offset             Offset of the cross chain block\n     * @custom:field sourceBlockHeight  Height of the source chain block\n     * @custom:field sourceBlockHash    Hash of the source chain block\n     */\n    struct BlockHeader {\n        uint64 sourceChainId;\n        uint64 consensusChainId;\n        uint8 confLevel;\n        uint64 offset;\n        uint64 sourceBlockHeight;\n        bytes32 sourceBlockHash;\n    }\n\n    /**\n     * @notice The required parameters to submit xmsgs to an OmniPortal. Constructed by the relayer\n     *         by watching Omni's consensus chain, and source chain blocks.\n     * @custom:field attestationRoot  Merkle root of xchain block (XBlockRoot), attested to and signed by validators\n     * @custom:field validatorSetId   Unique identifier of the validator set that attested to this root\n     * @custom:field blockHeader      Block header, identifies xchain block\n     * @custom:field msgs             Messages to execute\n     * @custom:field proof            Multi proof of block header and messages, proven against attestationRoot\n     * @custom:field proofFlags       Multi proof flags\n     * @custom:field signatures       Array of validator signatures of the attestationRoot, and their public keys\n     */\n    struct Submission {\n        bytes32 attestationRoot;\n        uint64 validatorSetId;\n        BlockHeader blockHeader;\n        Msg[] msgs;\n        bytes32[] proof;\n        bool[] proofFlags;\n        SigTuple[] signatures;\n    }\n\n    /**\n     * @notice A tuple of a validator's ethereum address and signature over some digest.\n     * @custom:field validatorAddr  Validator ethereum address\n     * @custom:field signature      Validator signature over some digest; Ethereum 65 bytes [R || S || V] format.\n     */\n    struct SigTuple {\n        address validatorAddr;\n        bytes signature;\n    }\n\n    /**\n     * @notice An Omni validator, specified by their etheruem address and voting power.\n     * @custom:field addr   Validator ethereum address\n     * @custom:field power  Validator voting power\n     */\n    struct Validator {\n        address addr;\n        uint64 power;\n    }\n\n    /**\n     * @notice A chain in the \"omni network\" specified by its chain ID and supported shards.\n     * @custom:field chainId  Chain ID\n     * @custom:field shards   Supported shards\n     */\n    struct Chain {\n        uint64 chainId;\n        uint64[] shards;\n    }\n}\n"},"src/libraries/Quorum.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { XTypes } from \"./XTypes.sol\";\n\n/**\n * @title Quorum\n * @dev Defines quorum verification logic.\n */\nlibrary Quorum {\n    /**\n     * @notice Verifies that the given percentage of the total power has signed the given digest.\n     * @param digest        Signed hash\n     * @param sigs          Signatures to verify, must be sorted by validator address\n     * @param validators    Maps validator addresses to their voting power\n     * @param totalPower    Total voting power\n     * @param qNumerator    Numerator of the quorum threshold. Ex: 2/3 -> 2\n     * @param qDenominator  Denominator of the quorum threshold. Ex: 2/3 -> 3\n     */\n    function verify(\n        bytes32 digest,\n        XTypes.SigTuple[] calldata sigs,\n        mapping(address => uint64) storage validators,\n        uint64 totalPower,\n        uint8 qNumerator,\n        uint8 qDenominator\n    ) internal view returns (bool) {\n        uint64 votedPower;\n        XTypes.SigTuple calldata sig;\n\n        for (uint256 i = 0; i < sigs.length; i++) {\n            sig = sigs[i];\n\n            if (i > 0) {\n                XTypes.SigTuple calldata prev = sigs[i - 1];\n                require(sig.validatorAddr > prev.validatorAddr, \"Quorum: sigs not deduped/sorted\");\n            }\n\n            require(_isValidSig(sig, digest), \"Quorum: invalid signature\");\n\n            votedPower += validators[sig.validatorAddr];\n\n            if (_isQuorum(votedPower, totalPower, qNumerator, qDenominator)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev True if SigTuple.sig is a valid ECDSA signature over the given digest for SigTuple.addr, else false.\n    function _isValidSig(XTypes.SigTuple calldata sig, bytes32 digest) internal pure returns (bool) {\n        return ECDSA.recover(digest, sig.signature) == sig.validatorAddr;\n    }\n\n    /// @dev True if votedPower exceeds the quorum threshold of numerator/denominator, else false.\n    function _isQuorum(uint64 votedPower, uint64 totalPower, uint8 numerator, uint8 denominator)\n        private\n        pure\n        returns (bool)\n    {\n        return votedPower * uint256(denominator) > totalPower * uint256(numerator);\n    }\n}\n"},"src/libraries/ConfLevel.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * @title ConfLevel\n * @notice XMsg confirmation levels. Matches ConfLevels in lib/xchain/types.go\n * @dev We prefer explicit constants over Enums, because we want uint8 values to start at 1, not 0, as they do in\n *      lib/xchain/types.go, such that 0 can represent \"unset\". Note only latest and finalized levels are supported\n *      on-chain.\n */\nlibrary ConfLevel {\n    /**\n     * @notice XMsg confirmation level \"latest\", last byte of xmsg.shardId.\n     */\n    uint8 internal constant Latest = 1;\n\n    /**\n     * @notice XMsg confirmation level \"finalized\", last byte of xmsg.shardId.\n     */\n    uint8 internal constant Finalized = 4;\n\n    /**\n     * @notice Returns true if the given level is valid.\n     */\n    function isValid(uint8 level) internal pure returns (bool) {\n        return level == Latest || level == Finalized;\n    }\n\n    /**\n     * @notice Returns broadcast shard version of the given level.\n     */\n    function toBroadcastShard(uint8 level) internal pure returns (uint64) {\n        return uint64(level) | 0x0100;\n    }\n}\n"},"src/utils/PausableUpgradeable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.24;\n\n/**\n * @title PausableUpgradeable\n * @notice Contract module which provides a way to pause certain functions by key.\n * @dev We use a map of bytes32 key to bools, rather than uint256 bitmap, to allow keys to be generated dynamically.\n *      This allows for flexible pausing, but at higher gas cost.\n */\ncontract PausableUpgradeable {\n    /// @notice Emitted when a key is paused.\n    event Paused(bytes32 indexed key);\n\n    /// @notice Emitted when a key is unpaused.\n    event Unpaused(bytes32 indexed key);\n\n    /// @custom:storage-location erc7201:omni.storage.Pauseable\n    struct PauseableStorage {\n        mapping(bytes32 => bool) _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"omni.storage.Pauseable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageSlot = 0xff37105740f03695c8f3597f3aff2b92fbe1c80abea3c28731ecff2efd693400;\n\n    function _getPauseableStorage() internal pure returns (PauseableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageSlot\n        }\n    }\n\n    /**\n     * @dev Special key for pausing all keys.\n     */\n    bytes32 public constant KeyPauseAll = keccak256(\"PAUSE_ALL\");\n\n    /**\n     * @notice Pause by key.\n     */\n    function _pause(bytes32 key) internal {\n        PauseableStorage storage $ = _getPauseableStorage();\n        require(!$._paused[key], \"Pausable: paused\");\n        $._paused[key] = true;\n        emit Paused(key);\n    }\n\n    /**\n     * @notice Unpause by key.\n     */\n    function _unpause(bytes32 key) internal {\n        PauseableStorage storage $ = _getPauseableStorage();\n        require($._paused[key], \"Pausable: not paused\");\n        $._paused[key] = false;\n        emit Unpaused(key);\n    }\n\n    /**\n     * @notice Returns true if `key` is paused, or all keys are paused.\n     */\n    function _isPaused(bytes32 key) internal view returns (bool) {\n        PauseableStorage storage $ = _getPauseableStorage();\n        return $._paused[KeyPauseAll] || $._paused[key];\n    }\n\n    /**\n     * @notice Returns true if either `key1` or `key2` is paused, or all keys are paused.\n     */\n    function _isPaused(bytes32 key1, bytes32 key2) internal view returns (bool) {\n        PauseableStorage storage $ = _getPauseableStorage();\n        return $._paused[KeyPauseAll] || $._paused[key1] || $._paused[key2];\n    }\n\n    /**\n     * @notice Returns true if all keys are paused.\n     */\n    function _isAllPaused() internal view returns (bool) {\n        PauseableStorage storage $ = _getPauseableStorage();\n        return $._paused[KeyPauseAll];\n    }\n\n    /**\n     * @notice Pause all keys.\n     */\n    function _pauseAll() internal {\n        _pause(KeyPauseAll);\n    }\n\n    /**\n     * @notice Unpause all keys.\n     */\n    function _unpauseAll() internal {\n        _unpause(KeyPauseAll);\n    }\n}\n"},"src/xchain/OmniPortalConstants.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * @title OmniPortalConstants\n * @notice Constants used by the OmniPortal contract\n */\ncontract OmniPortalConstants {\n    /**\n     * @notice Numerator of the fraction of total validator power required to accept an XSubmission. Ex 2/3 -> 2\n     */\n    uint8 public constant XSubQuorumNumerator = 2;\n\n    /**\n     * @notice Denominator of the fraction of total validator power required to accept an XSubmission. Ex 2/3 -> 3\n     */\n    uint8 public constant XSubQuorumDenominator = 3;\n\n    /**\n     * @notice Action ID for xsubmissions, used as Pauseable key\n     */\n    bytes32 public constant ActionXSubmit = keccak256(\"xsubmit\");\n\n    /**\n     * @notice Action ID for xcalls, used as Pauseable key\n     */\n    bytes32 public constant ActionXCall = keccak256(\"xcall\");\n\n    /**\n     * @dev xmsg.destChainId for \"broadcast\" xcalls, intended for all portals\n     */\n    uint64 internal constant BroadcastChainId = 0;\n\n    /**\n     * @dev xmsg.sender for xmsgs from Omni's consensus chain\n     */\n    address internal constant CChainSender = address(0);\n\n    /**\n     * @dev xmsg.to for xcalls to be executed on the portal itself\n     */\n    address internal constant VirtualPortalAddress = address(0);\n}\n"},"src/xchain/OmniPortalStorage.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.24;\n\nimport { IOmniPortal } from \"../interfaces/IOmniPortal.sol\";\nimport { IOmniPortalAdmin } from \"../interfaces/IOmniPortalAdmin.sol\";\nimport { XTypes } from \"../libraries/XTypes.sol\";\n\n/**\n * @title OmniPortalStorage\n * @notice Storage layout for OmniPortal\n */\nabstract contract OmniPortalStorage is IOmniPortal, IOmniPortalAdmin {\n    /**\n     * @notice Number of validator sets since the latest that can be used to validate an XSubmission\n     */\n    uint8 public xsubValsetCutoff;\n\n    /**\n     * @notice Maxium number of bytes allowed in xreceipt result\n     */\n    uint16 public xreceiptMaxErrorSize;\n\n    /**\n     * @notice Maximum number of bytes allowed in xmsg data\n     */\n    uint16 public xmsgMaxDataSize;\n\n    /**\n     * @notice Maximum allowed xmsg gas limit\n     */\n    uint64 public xmsgMaxGasLimit;\n\n    /**\n     * @notice Minimum allowed xmsg gas limit\n     */\n    uint64 public xmsgMinGasLimit;\n\n    /**\n     * @notice ID of the latest validator set relayed to this portal from the consensus chain.\n     */\n    uint64 public latestValSetId;\n\n    /**\n     * @notice Chain ID of Omni's EVM execution chain\n     */\n    uint64 public omniChainId;\n\n    /**\n     * @notice Virtual Chain ID of Omni's consensus chain\n     */\n    uint64 public omniCChainId;\n\n    /**\n     * @notice The address of the fee oracle contract\n     */\n    address public feeOracle;\n\n    /**\n     * @notice A list of supported chains & shards.\n     */\n    XTypes.Chain[] internal _network;\n\n    /**\n     * @notice Maps shard ID to true, if the shard is supported.\n     */\n    mapping(uint64 => bool) public isSupportedShard;\n\n    /**\n     * @notice Maps chain ID to true, if the chain is supported.\n     */\n    mapping(uint64 => bool) public isSupportedDest;\n\n    /**\n     * @notice Offset of the last outbound XMsg that was sent to destChainId in shardId\n     *         Maps destChainId -> shardId -> offset.\n     */\n    mapping(uint64 => mapping(uint64 => uint64)) public outXMsgOffset;\n\n    /**\n     * @notice Offset of the last inbound XMsg that was sent from sourceChainId in shardId\n     *         Maps sourceChainId -> shardId -> offset.\n     */\n    mapping(uint64 => mapping(uint64 => uint64)) public inXMsgOffset;\n\n    /**\n     * @notice The xblock offset of the last inbound XMsg that was received from sourceChainId in shardId\n     *         Maps sourceChainId -> shardId -> xblockOffset.\n     */\n    mapping(uint64 => mapping(uint64 => uint64)) public inXBlockOffset;\n\n    /**\n     * @notice Maps validator set id -> total power\n     */\n    mapping(uint64 => uint64) public valSetTotalPower;\n\n    /**\n     * @notice Maps validator set id -> validator address -> power\n     */\n    mapping(uint64 => mapping(address => uint64)) public valSet;\n\n    /**\n     * @notice The current XMsg being executed, exposed via xmsg() getter\n     * @dev Internal state + public getter preferred over public state with default getter\n     *      so that we can use the XMsg struct type in the interface.\n     */\n    XTypes.MsgContext internal _xmsg;\n}\n"},"node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/cryptography/MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"}},"settings":{"remappings":["forge-std/=node_modules/forge-std/src/","ds-test/=node_modules/ds-test/src/","src/=src/","test/=test/","avs/=../avs/src/","@openzeppelin-upgrades/contracts/=node_modules/@openzeppelin/contracts-upgradeable/","@nomad-xyz/=node_modules/@nomad-xyz/","@openzeppelin-v4/=node_modules/@openzeppelin-v4/","@openzeppelin/=node_modules/@openzeppelin/","eigenlayer-contracts/=node_modules/eigenlayer-contracts/","eigenlayer-middleware/=node_modules/eigenlayer-middleware/","multiproof/=node_modules/multiproof/","solmate/=node_modules/solmate/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
