// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package indexer

import (
	context "context"

	ormlist "cosmossdk.io/orm/model/ormlist"
	ormtable "cosmossdk.io/orm/model/ormtable"
	ormerrors "cosmossdk.io/orm/types/ormerrors"
)

type BlockTable interface {
	Insert(ctx context.Context, block *Block) error
	InsertReturningId(ctx context.Context, block *Block) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, block *Block) error
	Save(ctx context.Context, block *Block) error
	Delete(ctx context.Context, block *Block) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*Block, error)
	HasByChainIdBlockHeightBlockHash(ctx context.Context, chain_id uint64, block_height uint64, block_hash []byte) (found bool, err error)
	// GetByChainIdBlockHeightBlockHash returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByChainIdBlockHeightBlockHash(ctx context.Context, chain_id uint64, block_height uint64, block_hash []byte) (*Block, error)
	List(ctx context.Context, prefixKey BlockIndexKey, opts ...ormlist.Option) (BlockIterator, error)
	ListRange(ctx context.Context, from, to BlockIndexKey, opts ...ormlist.Option) (BlockIterator, error)
	DeleteBy(ctx context.Context, prefixKey BlockIndexKey) error
	DeleteRange(ctx context.Context, from, to BlockIndexKey) error

	doNotImplement()
}

type BlockIterator struct {
	ormtable.Iterator
}

func (i BlockIterator) Value() (*Block, error) {
	var block Block
	err := i.UnmarshalMessage(&block)
	return &block, err
}

type BlockIndexKey interface {
	id() uint32
	values() []interface{}
	blockIndexKey()
}

// primary key starting index..
type BlockPrimaryKey = BlockIdIndexKey

type BlockIdIndexKey struct {
	vs []interface{}
}

func (x BlockIdIndexKey) id() uint32            { return 0 }
func (x BlockIdIndexKey) values() []interface{} { return x.vs }
func (x BlockIdIndexKey) blockIndexKey()        {}

func (this BlockIdIndexKey) WithId(id uint64) BlockIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type BlockChainIdBlockHeightBlockHashIndexKey struct {
	vs []interface{}
}

func (x BlockChainIdBlockHeightBlockHashIndexKey) id() uint32            { return 2 }
func (x BlockChainIdBlockHeightBlockHashIndexKey) values() []interface{} { return x.vs }
func (x BlockChainIdBlockHeightBlockHashIndexKey) blockIndexKey()        {}

func (this BlockChainIdBlockHeightBlockHashIndexKey) WithChainId(chain_id uint64) BlockChainIdBlockHeightBlockHashIndexKey {
	this.vs = []interface{}{chain_id}
	return this
}

func (this BlockChainIdBlockHeightBlockHashIndexKey) WithChainIdBlockHeight(chain_id uint64, block_height uint64) BlockChainIdBlockHeightBlockHashIndexKey {
	this.vs = []interface{}{chain_id, block_height}
	return this
}

func (this BlockChainIdBlockHeightBlockHashIndexKey) WithChainIdBlockHeightBlockHash(chain_id uint64, block_height uint64, block_hash []byte) BlockChainIdBlockHeightBlockHashIndexKey {
	this.vs = []interface{}{chain_id, block_height, block_hash}
	return this
}

type blockTable struct {
	table ormtable.AutoIncrementTable
}

func (this blockTable) Insert(ctx context.Context, block *Block) error {
	return this.table.Insert(ctx, block)
}

func (this blockTable) Update(ctx context.Context, block *Block) error {
	return this.table.Update(ctx, block)
}

func (this blockTable) Save(ctx context.Context, block *Block) error {
	return this.table.Save(ctx, block)
}

func (this blockTable) Delete(ctx context.Context, block *Block) error {
	return this.table.Delete(ctx, block)
}

func (this blockTable) InsertReturningId(ctx context.Context, block *Block) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, block)
}

func (this blockTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this blockTable) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this blockTable) Get(ctx context.Context, id uint64) (*Block, error) {
	var block Block
	found, err := this.table.PrimaryKey().Get(ctx, &block, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &block, nil
}

func (this blockTable) HasByChainIdBlockHeightBlockHash(ctx context.Context, chain_id uint64, block_height uint64, block_hash []byte) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		chain_id,
		block_height,
		block_hash,
	)
}

func (this blockTable) GetByChainIdBlockHeightBlockHash(ctx context.Context, chain_id uint64, block_height uint64, block_hash []byte) (*Block, error) {
	var block Block
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &block,
		chain_id,
		block_height,
		block_hash,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &block, nil
}

func (this blockTable) List(ctx context.Context, prefixKey BlockIndexKey, opts ...ormlist.Option) (BlockIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BlockIterator{it}, err
}

func (this blockTable) ListRange(ctx context.Context, from, to BlockIndexKey, opts ...ormlist.Option) (BlockIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BlockIterator{it}, err
}

func (this blockTable) DeleteBy(ctx context.Context, prefixKey BlockIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this blockTable) DeleteRange(ctx context.Context, from, to BlockIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this blockTable) doNotImplement() {}

var _ BlockTable = blockTable{}

func NewBlockTable(db ormtable.Schema) (BlockTable, error) {
	table := db.GetTable(&Block{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Block{}).ProtoReflect().Descriptor().FullName()))
	}
	return blockTable{table.(ormtable.AutoIncrementTable)}, nil
}

type MsgLinkTable interface {
	Insert(ctx context.Context, msgLink *MsgLink) error
	Update(ctx context.Context, msgLink *MsgLink) error
	Save(ctx context.Context, msgLink *MsgLink) error
	Delete(ctx context.Context, msgLink *MsgLink) error
	Has(ctx context.Context, id_hash []byte) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id_hash []byte) (*MsgLink, error)
	List(ctx context.Context, prefixKey MsgLinkIndexKey, opts ...ormlist.Option) (MsgLinkIterator, error)
	ListRange(ctx context.Context, from, to MsgLinkIndexKey, opts ...ormlist.Option) (MsgLinkIterator, error)
	DeleteBy(ctx context.Context, prefixKey MsgLinkIndexKey) error
	DeleteRange(ctx context.Context, from, to MsgLinkIndexKey) error

	doNotImplement()
}

type MsgLinkIterator struct {
	ormtable.Iterator
}

func (i MsgLinkIterator) Value() (*MsgLink, error) {
	var msgLink MsgLink
	err := i.UnmarshalMessage(&msgLink)
	return &msgLink, err
}

type MsgLinkIndexKey interface {
	id() uint32
	values() []interface{}
	msgLinkIndexKey()
}

// primary key starting index..
type MsgLinkPrimaryKey = MsgLinkIdHashIndexKey

type MsgLinkIdHashIndexKey struct {
	vs []interface{}
}

func (x MsgLinkIdHashIndexKey) id() uint32            { return 0 }
func (x MsgLinkIdHashIndexKey) values() []interface{} { return x.vs }
func (x MsgLinkIdHashIndexKey) msgLinkIndexKey()      {}

func (this MsgLinkIdHashIndexKey) WithIdHash(id_hash []byte) MsgLinkIdHashIndexKey {
	this.vs = []interface{}{id_hash}
	return this
}

type msgLinkTable struct {
	table ormtable.Table
}

func (this msgLinkTable) Insert(ctx context.Context, msgLink *MsgLink) error {
	return this.table.Insert(ctx, msgLink)
}

func (this msgLinkTable) Update(ctx context.Context, msgLink *MsgLink) error {
	return this.table.Update(ctx, msgLink)
}

func (this msgLinkTable) Save(ctx context.Context, msgLink *MsgLink) error {
	return this.table.Save(ctx, msgLink)
}

func (this msgLinkTable) Delete(ctx context.Context, msgLink *MsgLink) error {
	return this.table.Delete(ctx, msgLink)
}

func (this msgLinkTable) Has(ctx context.Context, id_hash []byte) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id_hash)
}

func (this msgLinkTable) Get(ctx context.Context, id_hash []byte) (*MsgLink, error) {
	var msgLink MsgLink
	found, err := this.table.PrimaryKey().Get(ctx, &msgLink, id_hash)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &msgLink, nil
}

func (this msgLinkTable) List(ctx context.Context, prefixKey MsgLinkIndexKey, opts ...ormlist.Option) (MsgLinkIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return MsgLinkIterator{it}, err
}

func (this msgLinkTable) ListRange(ctx context.Context, from, to MsgLinkIndexKey, opts ...ormlist.Option) (MsgLinkIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return MsgLinkIterator{it}, err
}

func (this msgLinkTable) DeleteBy(ctx context.Context, prefixKey MsgLinkIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this msgLinkTable) DeleteRange(ctx context.Context, from, to MsgLinkIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this msgLinkTable) doNotImplement() {}

var _ MsgLinkTable = msgLinkTable{}

func NewMsgLinkTable(db ormtable.Schema) (MsgLinkTable, error) {
	table := db.GetTable(&MsgLink{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&MsgLink{}).ProtoReflect().Descriptor().FullName()))
	}
	return msgLinkTable{table}, nil
}

type CursorTable interface {
	Insert(ctx context.Context, cursor *Cursor) error
	Update(ctx context.Context, cursor *Cursor) error
	Save(ctx context.Context, cursor *Cursor) error
	Delete(ctx context.Context, cursor *Cursor) error
	Has(ctx context.Context, chain_id uint64, conf_level uint32) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, chain_id uint64, conf_level uint32) (*Cursor, error)
	List(ctx context.Context, prefixKey CursorIndexKey, opts ...ormlist.Option) (CursorIterator, error)
	ListRange(ctx context.Context, from, to CursorIndexKey, opts ...ormlist.Option) (CursorIterator, error)
	DeleteBy(ctx context.Context, prefixKey CursorIndexKey) error
	DeleteRange(ctx context.Context, from, to CursorIndexKey) error

	doNotImplement()
}

type CursorIterator struct {
	ormtable.Iterator
}

func (i CursorIterator) Value() (*Cursor, error) {
	var cursor Cursor
	err := i.UnmarshalMessage(&cursor)
	return &cursor, err
}

type CursorIndexKey interface {
	id() uint32
	values() []interface{}
	cursorIndexKey()
}

// primary key starting index..
type CursorPrimaryKey = CursorChainIdConfLevelIndexKey

type CursorChainIdConfLevelIndexKey struct {
	vs []interface{}
}

func (x CursorChainIdConfLevelIndexKey) id() uint32            { return 0 }
func (x CursorChainIdConfLevelIndexKey) values() []interface{} { return x.vs }
func (x CursorChainIdConfLevelIndexKey) cursorIndexKey()       {}

func (this CursorChainIdConfLevelIndexKey) WithChainId(chain_id uint64) CursorChainIdConfLevelIndexKey {
	this.vs = []interface{}{chain_id}
	return this
}

func (this CursorChainIdConfLevelIndexKey) WithChainIdConfLevel(chain_id uint64, conf_level uint32) CursorChainIdConfLevelIndexKey {
	this.vs = []interface{}{chain_id, conf_level}
	return this
}

type cursorTable struct {
	table ormtable.Table
}

func (this cursorTable) Insert(ctx context.Context, cursor *Cursor) error {
	return this.table.Insert(ctx, cursor)
}

func (this cursorTable) Update(ctx context.Context, cursor *Cursor) error {
	return this.table.Update(ctx, cursor)
}

func (this cursorTable) Save(ctx context.Context, cursor *Cursor) error {
	return this.table.Save(ctx, cursor)
}

func (this cursorTable) Delete(ctx context.Context, cursor *Cursor) error {
	return this.table.Delete(ctx, cursor)
}

func (this cursorTable) Has(ctx context.Context, chain_id uint64, conf_level uint32) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, chain_id, conf_level)
}

func (this cursorTable) Get(ctx context.Context, chain_id uint64, conf_level uint32) (*Cursor, error) {
	var cursor Cursor
	found, err := this.table.PrimaryKey().Get(ctx, &cursor, chain_id, conf_level)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &cursor, nil
}

func (this cursorTable) List(ctx context.Context, prefixKey CursorIndexKey, opts ...ormlist.Option) (CursorIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return CursorIterator{it}, err
}

func (this cursorTable) ListRange(ctx context.Context, from, to CursorIndexKey, opts ...ormlist.Option) (CursorIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return CursorIterator{it}, err
}

func (this cursorTable) DeleteBy(ctx context.Context, prefixKey CursorIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this cursorTable) DeleteRange(ctx context.Context, from, to CursorIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this cursorTable) doNotImplement() {}

var _ CursorTable = cursorTable{}

func NewCursorTable(db ormtable.Schema) (CursorTable, error) {
	table := db.GetTable(&Cursor{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Cursor{}).ProtoReflect().Descriptor().FullName()))
	}
	return cursorTable{table}, nil
}

type IndexerStore interface {
	BlockTable() BlockTable
	MsgLinkTable() MsgLinkTable
	CursorTable() CursorTable

	doNotImplement()
}

type indexerStore struct {
	block   BlockTable
	msgLink MsgLinkTable
	cursor  CursorTable
}

func (x indexerStore) BlockTable() BlockTable {
	return x.block
}

func (x indexerStore) MsgLinkTable() MsgLinkTable {
	return x.msgLink
}

func (x indexerStore) CursorTable() CursorTable {
	return x.cursor
}

func (indexerStore) doNotImplement() {}

var _ IndexerStore = indexerStore{}

func NewIndexerStore(db ormtable.Schema) (IndexerStore, error) {
	blockTable, err := NewBlockTable(db)
	if err != nil {
		return nil, err
	}

	msgLinkTable, err := NewMsgLinkTable(db)
	if err != nil {
		return nil, err
	}

	cursorTable, err := NewCursorTable(db)
	if err != nil {
		return nil, err
	}

	return indexerStore{
		blockTable,
		msgLinkTable,
		cursorTable,
	}, nil
}
