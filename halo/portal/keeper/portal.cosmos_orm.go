// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package keeper

import (
	context "context"
	ormlist "cosmossdk.io/orm/model/ormlist"
	ormtable "cosmossdk.io/orm/model/ormtable"
	ormerrors "cosmossdk.io/orm/types/ormerrors"
)

type BlockTable interface {
	Insert(ctx context.Context, block *Block) error
	InsertReturningId(ctx context.Context, block *Block) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, block *Block) error
	Save(ctx context.Context, block *Block) error
	Delete(ctx context.Context, block *Block) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*Block, error)
	HasByCreatedHeight(ctx context.Context, created_height uint64) (found bool, err error)
	// GetByCreatedHeight returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByCreatedHeight(ctx context.Context, created_height uint64) (*Block, error)
	List(ctx context.Context, prefixKey BlockIndexKey, opts ...ormlist.Option) (BlockIterator, error)
	ListRange(ctx context.Context, from, to BlockIndexKey, opts ...ormlist.Option) (BlockIterator, error)
	DeleteBy(ctx context.Context, prefixKey BlockIndexKey) error
	DeleteRange(ctx context.Context, from, to BlockIndexKey) error

	doNotImplement()
}

type BlockIterator struct {
	ormtable.Iterator
}

func (i BlockIterator) Value() (*Block, error) {
	var block Block
	err := i.UnmarshalMessage(&block)
	return &block, err
}

type BlockIndexKey interface {
	id() uint32
	values() []interface{}
	blockIndexKey()
}

// primary key starting index..
type BlockPrimaryKey = BlockIdIndexKey

type BlockIdIndexKey struct {
	vs []interface{}
}

func (x BlockIdIndexKey) id() uint32            { return 0 }
func (x BlockIdIndexKey) values() []interface{} { return x.vs }
func (x BlockIdIndexKey) blockIndexKey()        {}

func (this BlockIdIndexKey) WithId(id uint64) BlockIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type BlockCreatedHeightIndexKey struct {
	vs []interface{}
}

func (x BlockCreatedHeightIndexKey) id() uint32            { return 2 }
func (x BlockCreatedHeightIndexKey) values() []interface{} { return x.vs }
func (x BlockCreatedHeightIndexKey) blockIndexKey()        {}

func (this BlockCreatedHeightIndexKey) WithCreatedHeight(created_height uint64) BlockCreatedHeightIndexKey {
	this.vs = []interface{}{created_height}
	return this
}

type blockTable struct {
	table ormtable.AutoIncrementTable
}

func (this blockTable) Insert(ctx context.Context, block *Block) error {
	return this.table.Insert(ctx, block)
}

func (this blockTable) Update(ctx context.Context, block *Block) error {
	return this.table.Update(ctx, block)
}

func (this blockTable) Save(ctx context.Context, block *Block) error {
	return this.table.Save(ctx, block)
}

func (this blockTable) Delete(ctx context.Context, block *Block) error {
	return this.table.Delete(ctx, block)
}

func (this blockTable) InsertReturningId(ctx context.Context, block *Block) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, block)
}

func (this blockTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this blockTable) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this blockTable) Get(ctx context.Context, id uint64) (*Block, error) {
	var block Block
	found, err := this.table.PrimaryKey().Get(ctx, &block, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &block, nil
}

func (this blockTable) HasByCreatedHeight(ctx context.Context, created_height uint64) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		created_height,
	)
}

func (this blockTable) GetByCreatedHeight(ctx context.Context, created_height uint64) (*Block, error) {
	var block Block
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &block,
		created_height,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &block, nil
}

func (this blockTable) List(ctx context.Context, prefixKey BlockIndexKey, opts ...ormlist.Option) (BlockIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BlockIterator{it}, err
}

func (this blockTable) ListRange(ctx context.Context, from, to BlockIndexKey, opts ...ormlist.Option) (BlockIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BlockIterator{it}, err
}

func (this blockTable) DeleteBy(ctx context.Context, prefixKey BlockIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this blockTable) DeleteRange(ctx context.Context, from, to BlockIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this blockTable) doNotImplement() {}

var _ BlockTable = blockTable{}

func NewBlockTable(db ormtable.Schema) (BlockTable, error) {
	table := db.GetTable(&Block{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Block{}).ProtoReflect().Descriptor().FullName()))
	}
	return blockTable{table.(ormtable.AutoIncrementTable)}, nil
}

type MsgTable interface {
	Insert(ctx context.Context, msg *Msg) error
	InsertReturningId(ctx context.Context, msg *Msg) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, msg *Msg) error
	Save(ctx context.Context, msg *Msg) error
	Delete(ctx context.Context, msg *Msg) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*Msg, error)
	List(ctx context.Context, prefixKey MsgIndexKey, opts ...ormlist.Option) (MsgIterator, error)
	ListRange(ctx context.Context, from, to MsgIndexKey, opts ...ormlist.Option) (MsgIterator, error)
	DeleteBy(ctx context.Context, prefixKey MsgIndexKey) error
	DeleteRange(ctx context.Context, from, to MsgIndexKey) error

	doNotImplement()
}

type MsgIterator struct {
	ormtable.Iterator
}

func (i MsgIterator) Value() (*Msg, error) {
	var msg Msg
	err := i.UnmarshalMessage(&msg)
	return &msg, err
}

type MsgIndexKey interface {
	id() uint32
	values() []interface{}
	msgIndexKey()
}

// primary key starting index..
type MsgPrimaryKey = MsgIdIndexKey

type MsgIdIndexKey struct {
	vs []interface{}
}

func (x MsgIdIndexKey) id() uint32            { return 0 }
func (x MsgIdIndexKey) values() []interface{} { return x.vs }
func (x MsgIdIndexKey) msgIndexKey()          {}

func (this MsgIdIndexKey) WithId(id uint64) MsgIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type MsgBlockIdIndexKey struct {
	vs []interface{}
}

func (x MsgBlockIdIndexKey) id() uint32            { return 2 }
func (x MsgBlockIdIndexKey) values() []interface{} { return x.vs }
func (x MsgBlockIdIndexKey) msgIndexKey()          {}

func (this MsgBlockIdIndexKey) WithBlockId(block_id uint64) MsgBlockIdIndexKey {
	this.vs = []interface{}{block_id}
	return this
}

type msgTable struct {
	table ormtable.AutoIncrementTable
}

func (this msgTable) Insert(ctx context.Context, msg *Msg) error {
	return this.table.Insert(ctx, msg)
}

func (this msgTable) Update(ctx context.Context, msg *Msg) error {
	return this.table.Update(ctx, msg)
}

func (this msgTable) Save(ctx context.Context, msg *Msg) error {
	return this.table.Save(ctx, msg)
}

func (this msgTable) Delete(ctx context.Context, msg *Msg) error {
	return this.table.Delete(ctx, msg)
}

func (this msgTable) InsertReturningId(ctx context.Context, msg *Msg) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, msg)
}

func (this msgTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this msgTable) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this msgTable) Get(ctx context.Context, id uint64) (*Msg, error) {
	var msg Msg
	found, err := this.table.PrimaryKey().Get(ctx, &msg, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &msg, nil
}

func (this msgTable) List(ctx context.Context, prefixKey MsgIndexKey, opts ...ormlist.Option) (MsgIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return MsgIterator{it}, err
}

func (this msgTable) ListRange(ctx context.Context, from, to MsgIndexKey, opts ...ormlist.Option) (MsgIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return MsgIterator{it}, err
}

func (this msgTable) DeleteBy(ctx context.Context, prefixKey MsgIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this msgTable) DeleteRange(ctx context.Context, from, to MsgIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this msgTable) doNotImplement() {}

var _ MsgTable = msgTable{}

func NewMsgTable(db ormtable.Schema) (MsgTable, error) {
	table := db.GetTable(&Msg{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Msg{}).ProtoReflect().Descriptor().FullName()))
	}
	return msgTable{table.(ormtable.AutoIncrementTable)}, nil
}

type OffsetTable interface {
	Insert(ctx context.Context, offset *Offset) error
	InsertReturningId(ctx context.Context, offset *Offset) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, offset *Offset) error
	Save(ctx context.Context, offset *Offset) error
	Delete(ctx context.Context, offset *Offset) error
	Has(ctx context.Context, id uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, id uint64) (*Offset, error)
	HasByDestChainIdShardId(ctx context.Context, dest_chain_id uint64, shard_id uint64) (found bool, err error)
	// GetByDestChainIdShardId returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByDestChainIdShardId(ctx context.Context, dest_chain_id uint64, shard_id uint64) (*Offset, error)
	List(ctx context.Context, prefixKey OffsetIndexKey, opts ...ormlist.Option) (OffsetIterator, error)
	ListRange(ctx context.Context, from, to OffsetIndexKey, opts ...ormlist.Option) (OffsetIterator, error)
	DeleteBy(ctx context.Context, prefixKey OffsetIndexKey) error
	DeleteRange(ctx context.Context, from, to OffsetIndexKey) error

	doNotImplement()
}

type OffsetIterator struct {
	ormtable.Iterator
}

func (i OffsetIterator) Value() (*Offset, error) {
	var offset Offset
	err := i.UnmarshalMessage(&offset)
	return &offset, err
}

type OffsetIndexKey interface {
	id() uint32
	values() []interface{}
	offsetIndexKey()
}

// primary key starting index..
type OffsetPrimaryKey = OffsetIdIndexKey

type OffsetIdIndexKey struct {
	vs []interface{}
}

func (x OffsetIdIndexKey) id() uint32            { return 0 }
func (x OffsetIdIndexKey) values() []interface{} { return x.vs }
func (x OffsetIdIndexKey) offsetIndexKey()       {}

func (this OffsetIdIndexKey) WithId(id uint64) OffsetIdIndexKey {
	this.vs = []interface{}{id}
	return this
}

type OffsetDestChainIdShardIdIndexKey struct {
	vs []interface{}
}

func (x OffsetDestChainIdShardIdIndexKey) id() uint32            { return 2 }
func (x OffsetDestChainIdShardIdIndexKey) values() []interface{} { return x.vs }
func (x OffsetDestChainIdShardIdIndexKey) offsetIndexKey()       {}

func (this OffsetDestChainIdShardIdIndexKey) WithDestChainId(dest_chain_id uint64) OffsetDestChainIdShardIdIndexKey {
	this.vs = []interface{}{dest_chain_id}
	return this
}

func (this OffsetDestChainIdShardIdIndexKey) WithDestChainIdShardId(dest_chain_id uint64, shard_id uint64) OffsetDestChainIdShardIdIndexKey {
	this.vs = []interface{}{dest_chain_id, shard_id}
	return this
}

type offsetTable struct {
	table ormtable.AutoIncrementTable
}

func (this offsetTable) Insert(ctx context.Context, offset *Offset) error {
	return this.table.Insert(ctx, offset)
}

func (this offsetTable) Update(ctx context.Context, offset *Offset) error {
	return this.table.Update(ctx, offset)
}

func (this offsetTable) Save(ctx context.Context, offset *Offset) error {
	return this.table.Save(ctx, offset)
}

func (this offsetTable) Delete(ctx context.Context, offset *Offset) error {
	return this.table.Delete(ctx, offset)
}

func (this offsetTable) InsertReturningId(ctx context.Context, offset *Offset) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, offset)
}

func (this offsetTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this offsetTable) Has(ctx context.Context, id uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, id)
}

func (this offsetTable) Get(ctx context.Context, id uint64) (*Offset, error) {
	var offset Offset
	found, err := this.table.PrimaryKey().Get(ctx, &offset, id)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &offset, nil
}

func (this offsetTable) HasByDestChainIdShardId(ctx context.Context, dest_chain_id uint64, shard_id uint64) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		dest_chain_id,
		shard_id,
	)
}

func (this offsetTable) GetByDestChainIdShardId(ctx context.Context, dest_chain_id uint64, shard_id uint64) (*Offset, error) {
	var offset Offset
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &offset,
		dest_chain_id,
		shard_id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &offset, nil
}

func (this offsetTable) List(ctx context.Context, prefixKey OffsetIndexKey, opts ...ormlist.Option) (OffsetIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return OffsetIterator{it}, err
}

func (this offsetTable) ListRange(ctx context.Context, from, to OffsetIndexKey, opts ...ormlist.Option) (OffsetIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return OffsetIterator{it}, err
}

func (this offsetTable) DeleteBy(ctx context.Context, prefixKey OffsetIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this offsetTable) DeleteRange(ctx context.Context, from, to OffsetIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this offsetTable) doNotImplement() {}

var _ OffsetTable = offsetTable{}

func NewOffsetTable(db ormtable.Schema) (OffsetTable, error) {
	table := db.GetTable(&Offset{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Offset{}).ProtoReflect().Descriptor().FullName()))
	}
	return offsetTable{table.(ormtable.AutoIncrementTable)}, nil
}

type PortalStore interface {
	BlockTable() BlockTable
	MsgTable() MsgTable
	OffsetTable() OffsetTable

	doNotImplement()
}

type portalStore struct {
	block  BlockTable
	msg    MsgTable
	offset OffsetTable
}

func (x portalStore) BlockTable() BlockTable {
	return x.block
}

func (x portalStore) MsgTable() MsgTable {
	return x.msg
}

func (x portalStore) OffsetTable() OffsetTable {
	return x.offset
}

func (portalStore) doNotImplement() {}

var _ PortalStore = portalStore{}

func NewPortalStore(db ormtable.Schema) (PortalStore, error) {
	blockTable, err := NewBlockTable(db)
	if err != nil {
		return nil, err
	}

	msgTable, err := NewMsgTable(db)
	if err != nil {
		return nil, err
	}

	offsetTable, err := NewOffsetTable(db)
	if err != nil {
		return nil, err
	}

	return portalStore{
		blockTable,
		msgTable,
		offsetTable,
	}, nil
}
